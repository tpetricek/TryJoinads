<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" 
                        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
  <html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <title id="title">Computation expressions for additive monads</title>
    <link href="http://fonts.googleapis.com/css?family=Gudea" rel="stylesheet" type="text/css">
    <link rel="stylesheet" type="text/css" href="../../contentstyle.css" />
    <script type="text/javascript" src="../../tips.js"></script>
    <script type="text/javascript">

      var _gaq = _gaq || [];
      _gaq.push(['_setAccount', 'UA-1561220-5']);
      _gaq.push(['_setDomainName', 'tryjoinads.org']);
      _gaq.push(['_trackPageview']);

      (function() {
        var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
        ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
        var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
      })();

    </script>
  </head>
  <body class="content" onload="parent.updateTitle(document.getElementById('title').innerHTML)">
    <h1>Additive monads</h1>

<p>The previous sections demonstrated how to define F# computation expression for <em>monoidal</em> and <em>monadic</em>
computations. In this section, we look at computations that combine multiple aspects. We look at
computations that form <em>additive monads</em> (also called <code>MonadPlus</code> in Haskell), which means that they
provide both monadic and monoidal operations.</p>

<p>An additive monad is a monad (with <em>bind</em> and <em>return</em>) that also implements a binary operation 
<em>combine</em> (that can be used for combining two computations) and has a unit element. Two examples
of additive monads are parsers (where binary operation represents non-deterministic choice) and 
lists or other collections (where binary operation is the concatenation).</p>

<h2><a name="parsers">Computation builder for parsers</a></h2>

<p>The following snippet defines simple parser combinators and implements the basic operations that are
required in order to define a computation builder. The parser is represented as a function that takes
a list of characters and returns an sequence of possible results. Every element contains the
parsed result and an unconsumed buffer. Note that the <code>zero</code> operation is the 
unit with respect to <code>combine</code>.</p>

<pre class="fssnip runnable">
<span class="k">type</span> <span onmouseout="hideTip(event, 'ft1', 1)" onmouseover="showTip(event, 'ft1', 1)" class="i">Parser</span><span class="o">&lt;</span><span class="o">&#39;</span><span class="i">T</span><span class="o">&gt;</span> <span class="o">=</span> <span onmouseout="hideTip(event, 'ft2', 2)" onmouseover="showTip(event, 'ft2', 2)" class="i">P</span> <span class="k">of</span> (<span onmouseout="hideTip(event, 'ft3', 3)" onmouseover="showTip(event, 'ft3', 3)" class="i">list</span><span class="o">&lt;</span><span onmouseout="hideTip(event, 'ft4', 4)" onmouseover="showTip(event, 'ft4', 4)" class="i">char</span><span class="o">&gt;</span> <span class="k">-&gt;</span> <span onmouseout="hideTip(event, 'ft5', 5)" onmouseover="showTip(event, 'ft5', 5)" class="i">seq</span><span class="o">&lt;</span><span class="o">&#39;</span><span class="i">T</span> <span class="o">*</span> <span onmouseout="hideTip(event, 'ft3', 6)" onmouseover="showTip(event, 'ft3', 6)" class="i">list</span><span class="o">&lt;</span><span onmouseout="hideTip(event, 'ft4', 7)" onmouseover="showTip(event, 'ft4', 7)" class="i">char</span><span class="o">&gt;</span><span class="o">&gt;</span>)

<span class="c">/// Run the parser and return the first result (or None)</span>
<span class="k">let</span> <span onmouseout="hideTip(event, 'ft6', 8)" onmouseover="showTip(event, 'ft6', 8)" class="i">run</span> (<span onmouseout="hideTip(event, 'ft2', 9)" onmouseover="showTip(event, 'ft2', 9)" class="i">P</span> <span onmouseout="hideTip(event, 'ft7', 10)" onmouseover="showTip(event, 'ft7', 10)" class="i">f</span>) <span class="o">=</span> <span onmouseout="hideTip(event, 'ft8', 11)" onmouseover="showTip(event, 'ft8', 11)" class="i">List</span><span class="o">.</span><span onmouseout="hideTip(event, 'ft9', 12)" onmouseover="showTip(event, 'ft9', 12)" class="i">ofSeq</span> <span class="o">&gt;</span><span class="o">&gt;</span> <span onmouseout="hideTip(event, 'ft7', 13)" onmouseover="showTip(event, 'ft7', 13)" class="i">f</span> <span class="o">&gt;</span><span class="o">&gt;</span> <span onmouseout="hideTip(event, 'ft10', 14)" onmouseover="showTip(event, 'ft10', 14)" class="i">Seq</span><span class="o">.</span><span onmouseout="hideTip(event, 'ft11', 15)" onmouseover="showTip(event, 'ft11', 15)" class="i">map</span> <span onmouseout="hideTip(event, 'ft12', 16)" onmouseover="showTip(event, 'ft12', 16)" class="i">fst</span> <span class="o">&gt;</span><span class="o">&gt;</span> <span onmouseout="hideTip(event, 'ft10', 17)" onmouseover="showTip(event, 'ft10', 17)" class="i">Seq</span><span class="o">.</span><span onmouseout="hideTip(event, 'ft13', 18)" onmouseover="showTip(event, 'ft13', 18)" class="i">tryPick</span> <span onmouseout="hideTip(event, 'ft14', 19)" onmouseover="showTip(event, 'ft14', 19)" class="i">Some</span>

<span class="k">module</span> <span class="i">Parsers</span> <span class="o">=</span> 
  <span class="c">/// Parser that succeeds without consuming any input</span>
  <span class="k">let</span> <span onmouseout="hideTip(event, 'ft15', 20)" onmouseover="showTip(event, 'ft15', 20)" class="i">unit</span> <span onmouseout="hideTip(event, 'ft16', 21)" onmouseover="showTip(event, 'ft16', 21)" class="i">v</span> <span class="o">=</span> <span onmouseout="hideTip(event, 'ft2', 22)" onmouseover="showTip(event, 'ft2', 22)" class="i">P</span> (<span class="k">fun</span> <span onmouseout="hideTip(event, 'ft17', 23)" onmouseover="showTip(event, 'ft17', 23)" class="i">buffer</span> <span class="k">-&gt;</span> <span onmouseout="hideTip(event, 'ft5', 24)" onmouseover="showTip(event, 'ft5', 24)" class="i">seq</span> [<span onmouseout="hideTip(event, 'ft16', 25)" onmouseover="showTip(event, 'ft16', 25)" class="i">v</span>, <span onmouseout="hideTip(event, 'ft17', 26)" onmouseover="showTip(event, 'ft17', 26)" class="i">buffer</span>])

  <span class="c">/// Runs the first parser and then a parser </span>
  <span class="c">/// generated by the provided function</span>
  <span class="k">let</span> <span onmouseout="hideTip(event, 'ft18', 27)" onmouseover="showTip(event, 'ft18', 27)" class="i">bind</span> <span onmouseout="hideTip(event, 'ft19', 28)" onmouseover="showTip(event, 'ft19', 28)" class="i">f</span> (<span onmouseout="hideTip(event, 'ft2', 29)" onmouseover="showTip(event, 'ft2', 29)" class="i">P</span> <span onmouseout="hideTip(event, 'ft20', 30)" onmouseover="showTip(event, 'ft20', 30)" class="i">p1</span>) <span class="o">=</span> <span onmouseout="hideTip(event, 'ft2', 31)" onmouseover="showTip(event, 'ft2', 31)" class="i">P</span> (<span class="k">fun</span> <span onmouseout="hideTip(event, 'ft17', 32)" onmouseover="showTip(event, 'ft17', 32)" class="i">buffer</span> <span class="k">-&gt;</span>
    <span onmouseout="hideTip(event, 'ft5', 33)" onmouseover="showTip(event, 'ft5', 33)" class="i">seq</span> { <span class="k">for</span> (<span onmouseout="hideTip(event, 'ft16', 34)" onmouseover="showTip(event, 'ft16', 34)" class="i">v</span>, <span onmouseout="hideTip(event, 'ft17', 35)" onmouseover="showTip(event, 'ft17', 35)" class="i">buffer</span>) <span class="k">in</span> <span onmouseout="hideTip(event, 'ft20', 36)" onmouseover="showTip(event, 'ft20', 36)" class="i">p1</span> <span onmouseout="hideTip(event, 'ft17', 37)" onmouseover="showTip(event, 'ft17', 37)" class="i">buffer</span> <span class="k">do</span>
            <span class="k">let</span> (<span onmouseout="hideTip(event, 'ft2', 38)" onmouseover="showTip(event, 'ft2', 38)" class="i">P</span> <span onmouseout="hideTip(event, 'ft21', 39)" onmouseover="showTip(event, 'ft21', 39)" class="i">p2</span>) <span class="o">=</span> <span onmouseout="hideTip(event, 'ft19', 40)" onmouseover="showTip(event, 'ft19', 40)" class="i">f</span> <span onmouseout="hideTip(event, 'ft16', 41)" onmouseover="showTip(event, 'ft16', 41)" class="i">v</span> 
            <span class="k">yield!</span> <span onmouseout="hideTip(event, 'ft21', 42)" onmouseover="showTip(event, 'ft21', 42)" class="i">p2</span> <span onmouseout="hideTip(event, 'ft17', 43)" onmouseover="showTip(event, 'ft17', 43)" class="i">buffer</span> })

  <span class="c">/// Represents a parser that always fails</span>
  <span class="k">let</span> <span onmouseout="hideTip(event, 'ft22', 44)" onmouseover="showTip(event, 'ft22', 44)" class="i">zero</span> () <span class="o">=</span> <span onmouseout="hideTip(event, 'ft2', 45)" onmouseover="showTip(event, 'ft2', 45)" class="i">P</span> (<span class="k">fun</span> <span onmouseout="hideTip(event, 'ft17', 46)" onmouseover="showTip(event, 'ft17', 46)" class="i">buffer</span> <span class="k">-&gt;</span> <span onmouseout="hideTip(event, 'ft10', 47)" onmouseover="showTip(event, 'ft10', 47)" class="i">Seq</span><span class="o">.</span><span onmouseout="hideTip(event, 'ft23', 48)" onmouseover="showTip(event, 'ft23', 48)" class="i">empty</span>)

  <span class="c">/// Non-deterministic choice - combine all possible results</span>
  <span class="k">let</span> <span onmouseout="hideTip(event, 'ft24', 49)" onmouseover="showTip(event, 'ft24', 49)" class="i">combine</span> (<span onmouseout="hideTip(event, 'ft2', 50)" onmouseover="showTip(event, 'ft2', 50)" class="i">P</span> <span onmouseout="hideTip(event, 'ft20', 51)" onmouseover="showTip(event, 'ft20', 51)" class="i">p1</span>) (<span onmouseout="hideTip(event, 'ft2', 52)" onmouseover="showTip(event, 'ft2', 52)" class="i">P</span> <span onmouseout="hideTip(event, 'ft25', 53)" onmouseover="showTip(event, 'ft25', 53)" class="i">p2</span>) <span class="o">=</span> <span onmouseout="hideTip(event, 'ft2', 54)" onmouseover="showTip(event, 'ft2', 54)" class="i">P</span> (<span class="k">fun</span> <span onmouseout="hideTip(event, 'ft17', 55)" onmouseover="showTip(event, 'ft17', 55)" class="i">buffer</span> <span class="k">-&gt;</span>
    <span onmouseout="hideTip(event, 'ft10', 56)" onmouseover="showTip(event, 'ft10', 56)" class="i">Seq</span><span class="o">.</span><span onmouseout="hideTip(event, 'ft26', 57)" onmouseover="showTip(event, 'ft26', 57)" class="i">concat</span> [ <span onmouseout="hideTip(event, 'ft20', 58)" onmouseover="showTip(event, 'ft20', 58)" class="i">p1</span> <span onmouseout="hideTip(event, 'ft17', 59)" onmouseover="showTip(event, 'ft17', 59)" class="i">buffer</span>; <span onmouseout="hideTip(event, 'ft25', 60)" onmouseover="showTip(event, 'ft25', 60)" class="i">p2</span> <span onmouseout="hideTip(event, 'ft17', 61)" onmouseover="showTip(event, 'ft17', 61)" class="i">buffer</span> ])<br /><button class="run" onclick='parent.runCode("type Parser\u003c\u0027T\u003e = P of (list\u003cchar\u003e -\u003e seq\u003c\u0027T * list\u003cchar\u003e\u003e)\r\n\r\n/// Run the parser and return the first result (or None)\r\nlet run (P f) = List.ofSeq \u003e\u003e f \u003e\u003e Seq.map fst \u003e\u003e Seq.tryPick Some\r\n\r\nmodule Parsers = \r\n  /// Parser that succeeds without consuming any input\r\n  let unit v = P (fun buffer -\u003e seq [v, buffer])\r\n\r\n  /// Runs the first parser and then a parser \r\n  /// generated by the provided function\r\n  let bind f (P p1) = P (fun buffer -\u003e\r\n    seq { for (v, buffer) in p1 buffer do\r\n            let (P p2) = f v \r\n            yield! p2 buffer })\r\n\r\n  /// Represents a parser that always fails\r\n  let zero () = P (fun buffer -\u003e Seq.empty)\r\n\r\n  /// Non-deterministic choice - combine all possible results\r\n  let combine (P p1) (P p2) = P (fun buffer -\u003e\r\n    Seq.concat [ p1 buffer; p2 buffer ])");'></button></pre>


<p>Using the above operations, we can define a computation builder for working with additive monads.
The computation <code>Parser&lt;'T&gt;</code> can capture untracked effects (in the function) and so we also provide
an explicit <code>Delay</code> member (similarly to the <a href="monads.html">monadic examples</a>). Although the 
computation builder looks similar to the one for monads, it behaves quite differently, because
<code>zero</code> and <code>combine</code> are unique operations that are not defined in terms of <code>bind</code> and <code>return</code>:</p>

<pre class="fssnip runnable">
<span class="c">/// Computation builder for working with parsers</span>
<span class="k">type</span> <span onmouseout="hideTip(event, 'ft27', 62)" onmouseover="showTip(event, 'ft27', 62)" class="i">ParserBuilder</span>() <span class="o">=</span> 
  <span class="k">member</span> <span onmouseout="hideTip(event, 'ft28', 63)" onmouseover="showTip(event, 'ft28', 63)" class="i">x</span><span class="o">.</span><span onmouseout="hideTip(event, 'ft29', 64)" onmouseover="showTip(event, 'ft29', 64)" class="i">Return</span>(<span onmouseout="hideTip(event, 'ft30', 65)" onmouseover="showTip(event, 'ft30', 65)" class="i">v</span>) <span class="o">=</span> <span onmouseout="hideTip(event, 'ft31', 66)" onmouseover="showTip(event, 'ft31', 66)" class="i">Parsers</span><span class="o">.</span><span onmouseout="hideTip(event, 'ft32', 67)" onmouseover="showTip(event, 'ft32', 67)" class="i">unit</span> <span onmouseout="hideTip(event, 'ft30', 68)" onmouseover="showTip(event, 'ft30', 68)" class="i">v</span>
  <span class="k">member</span> <span onmouseout="hideTip(event, 'ft28', 69)" onmouseover="showTip(event, 'ft28', 69)" class="i">x</span><span class="o">.</span><span onmouseout="hideTip(event, 'ft33', 70)" onmouseover="showTip(event, 'ft33', 70)" class="i">ReturnFrom</span>(<span onmouseout="hideTip(event, 'ft34', 71)" onmouseover="showTip(event, 'ft34', 71)" class="i">m</span>) <span class="o">=</span> <span onmouseout="hideTip(event, 'ft34', 72)" onmouseover="showTip(event, 'ft34', 72)" class="i">m</span>
  <span class="k">member</span> <span onmouseout="hideTip(event, 'ft28', 73)" onmouseover="showTip(event, 'ft28', 73)" class="i">x</span><span class="o">.</span><span onmouseout="hideTip(event, 'ft35', 74)" onmouseover="showTip(event, 'ft35', 74)" class="i">Bind</span>(<span onmouseout="hideTip(event, 'ft36', 75)" onmouseover="showTip(event, 'ft36', 75)" class="i">v</span>, <span onmouseout="hideTip(event, 'ft37', 76)" onmouseover="showTip(event, 'ft37', 76)" class="i">f</span>) <span class="o">=</span> <span onmouseout="hideTip(event, 'ft31', 77)" onmouseover="showTip(event, 'ft31', 77)" class="i">Parsers</span><span class="o">.</span><span onmouseout="hideTip(event, 'ft18', 78)" onmouseover="showTip(event, 'ft18', 78)" class="i">bind</span> <span onmouseout="hideTip(event, 'ft37', 79)" onmouseover="showTip(event, 'ft37', 79)" class="i">f</span> <span onmouseout="hideTip(event, 'ft36', 80)" onmouseover="showTip(event, 'ft36', 80)" class="i">v</span>
  <span class="k">member</span> <span onmouseout="hideTip(event, 'ft28', 81)" onmouseover="showTip(event, 'ft28', 81)" class="i">x</span><span class="o">.</span><span onmouseout="hideTip(event, 'ft38', 82)" onmouseover="showTip(event, 'ft38', 82)" class="i">Zero</span>() <span class="o">=</span> <span onmouseout="hideTip(event, 'ft31', 83)" onmouseover="showTip(event, 'ft31', 83)" class="i">Parsers</span><span class="o">.</span><span onmouseout="hideTip(event, 'ft22', 84)" onmouseover="showTip(event, 'ft22', 84)" class="i">zero</span>()
  <span class="k">member</span> <span onmouseout="hideTip(event, 'ft28', 85)" onmouseover="showTip(event, 'ft28', 85)" class="i">x</span><span class="o">.</span><span onmouseout="hideTip(event, 'ft39', 86)" onmouseover="showTip(event, 'ft39', 86)" class="i">Combine</span>(<span onmouseout="hideTip(event, 'ft40', 87)" onmouseover="showTip(event, 'ft40', 87)" class="i">p1</span>, <span onmouseout="hideTip(event, 'ft41', 88)" onmouseover="showTip(event, 'ft41', 88)" class="i">p2</span>) <span class="o">=</span> <span onmouseout="hideTip(event, 'ft31', 89)" onmouseover="showTip(event, 'ft31', 89)" class="i">Parsers</span><span class="o">.</span><span onmouseout="hideTip(event, 'ft24', 90)" onmouseover="showTip(event, 'ft24', 90)" class="i">combine</span> <span onmouseout="hideTip(event, 'ft40', 91)" onmouseover="showTip(event, 'ft40', 91)" class="i">p1</span> <span onmouseout="hideTip(event, 'ft41', 92)" onmouseover="showTip(event, 'ft41', 92)" class="i">p2</span>
  <span class="k">member</span> <span onmouseout="hideTip(event, 'ft28', 93)" onmouseover="showTip(event, 'ft28', 93)" class="i">x</span><span class="o">.</span><span onmouseout="hideTip(event, 'ft42', 94)" onmouseover="showTip(event, 'ft42', 94)" class="i">Delay</span>(<span onmouseout="hideTip(event, 'ft43', 95)" onmouseover="showTip(event, 'ft43', 95)" class="i">f</span>) <span class="o">=</span> <span onmouseout="hideTip(event, 'ft2', 96)" onmouseover="showTip(event, 'ft2', 96)" class="i">P</span> (<span class="k">fun</span> <span onmouseout="hideTip(event, 'ft17', 97)" onmouseover="showTip(event, 'ft17', 97)" class="i">buffer</span> <span class="k">-&gt;</span> 
    <span class="k">let</span> (<span onmouseout="hideTip(event, 'ft2', 98)" onmouseover="showTip(event, 'ft2', 98)" class="i">P</span> <span onmouseout="hideTip(event, 'ft44', 99)" onmouseover="showTip(event, 'ft44', 99)" class="i">op</span>) <span class="o">=</span> <span onmouseout="hideTip(event, 'ft43', 100)" onmouseover="showTip(event, 'ft43', 100)" class="i">f</span> () <span class="k">in</span> <span onmouseout="hideTip(event, 'ft44', 101)" onmouseover="showTip(event, 'ft44', 101)" class="i">op</span> <span onmouseout="hideTip(event, 'ft17', 102)" onmouseover="showTip(event, 'ft17', 102)" class="i">buffer</span>)

<span class="c">/// A unique instance of the computation builder</span>
<span class="k">let</span> <span onmouseout="hideTip(event, 'ft45', 103)" onmouseover="showTip(event, 'ft45', 103)" class="i">parse</span> <span class="o">=</span> <span onmouseout="hideTip(event, 'ft27', 104)" onmouseover="showTip(event, 'ft27', 104)" class="i">ParserBuilder</span>()<br /><button class="run" onclick='parent.runCode("/// Computation builder for working with parsers\r\ntype ParserBuilder() = \r\n  member x.Return(v) = Parsers.unit v\r\n  member x.ReturnFrom(m) = m\r\n  member x.Bind(v, f) = Parsers.bind f v\r\n  member x.Zero() = Parsers.zero()\r\n  member x.Combine(p1, p2) = Parsers.combine p1 p2\r\n  member x.Delay(f) = P (fun buffer -\u003e \r\n    let (P op) = f () in op buffer)\r\n\r\n/// A unique instance of the computation builder\r\nlet parse = ParserBuilder()");'></button></pre>


<h3>Programming with parsers</h3>

<p>Using the above definition, we can write a number of interesting parsers as a computation. The 
following two examples (from the paper) represent parsers that repeat the specified parser <code>p</code>
one or more times and zero or more times respectively:</p>

<pre class="fssnip runnable">
<span class="c">/// Parse one or more occurrences of &#39;p&#39;</span>
<span class="k">let</span> <span class="k">rec</span> <span onmouseout="hideTip(event, 'ft46', 105)" onmouseover="showTip(event, 'ft46', 105)" class="i">oneOrMore</span> <span onmouseout="hideTip(event, 'ft47', 106)" onmouseover="showTip(event, 'ft47', 106)" class="i">p</span> <span class="o">=</span> <span onmouseout="hideTip(event, 'ft45', 107)" onmouseover="showTip(event, 'ft45', 107)" class="i">parse</span> { 
  <span class="k">let!</span> <span onmouseout="hideTip(event, 'ft48', 108)" onmouseover="showTip(event, 'ft48', 108)" class="i">x</span> <span class="o">=</span> <span onmouseout="hideTip(event, 'ft47', 109)" onmouseover="showTip(event, 'ft47', 109)" class="i">p</span>
  <span class="k">let!</span> <span onmouseout="hideTip(event, 'ft49', 110)" onmouseover="showTip(event, 'ft49', 110)" class="i">xs</span> <span class="o">=</span> <span onmouseout="hideTip(event, 'ft50', 111)" onmouseover="showTip(event, 'ft50', 111)" class="i">zeroOrMore</span> <span onmouseout="hideTip(event, 'ft47', 112)" onmouseover="showTip(event, 'ft47', 112)" class="i">p</span>
  <span class="k">return</span> <span onmouseout="hideTip(event, 'ft48', 113)" onmouseover="showTip(event, 'ft48', 113)" class="i">x</span><span class="o">::</span><span class="i">xs</span> }

<span class="c">/// Parse zero or more occurrences of &#39;p&#39;</span>
<span class="k">and</span> <span onmouseout="hideTip(event, 'ft50', 114)" onmouseover="showTip(event, 'ft50', 114)" class="i">zeroOrMore</span> <span onmouseout="hideTip(event, 'ft47', 115)" onmouseover="showTip(event, 'ft47', 115)" class="i">p</span> <span class="o">=</span> <span onmouseout="hideTip(event, 'ft45', 116)" onmouseover="showTip(event, 'ft45', 116)" class="i">parse</span> {
  <span class="k">return!</span> <span onmouseout="hideTip(event, 'ft46', 117)" onmouseover="showTip(event, 'ft46', 117)" class="i">oneOrMore</span> <span onmouseout="hideTip(event, 'ft47', 118)" onmouseover="showTip(event, 'ft47', 118)" class="i">p</span>
  <span class="k">return</span> [] }<br /><button class="run" onclick='parent.runCode("/// Parse one or more occurrences of \u0027p\u0027\r\nlet rec oneOrMore p = parse { \r\n  let! x = p\r\n  let! xs = zeroOrMore p\r\n  return x::xs }\r\n\r\n/// Parse zero or more occurrences of \u0027p\u0027\r\nand zeroOrMore p = parse {\r\n  return! oneOrMore p\r\n  return [] }");'></button></pre>


<p>As discussed in the paper, the <code>oneOrMore</code> computation uses the monadic interface. It 
sequentially composes parser <code>p</code> follwed by <code>zeroOrMore p</code>, which means that it always needs
to parse <code>p</code> first (at least once). The parser <code>zeroOrMore</code> uses the monoidal interface - it
combines the results of <code>oneOrMore p</code> (which parses <code>p</code> at least once) with a parser that
succeeds immediately, returning an emtpy list. In the translation, the first function 
uses <code>Bind</code> and <code>Return</code>, while the second one uses <code>Combine</code>:</p>

<pre class="fssnip">
<span class="k">let</span> <span class="k">rec</span> <span onmouseout="hideTip(event, 'ft51', 119)" onmouseover="showTip(event, 'ft51', 119)" class="i">oneOrMore</span> <span onmouseout="hideTip(event, 'ft47', 120)" onmouseover="showTip(event, 'ft47', 120)" class="i">p</span> <span class="o">=</span> 
  <span onmouseout="hideTip(event, 'ft45', 121)" onmouseover="showTip(event, 'ft45', 121)" class="i">parse</span><span class="o">.</span><span onmouseout="hideTip(event, 'ft52', 122)" onmouseover="showTip(event, 'ft52', 122)" class="i">Delay</span>(<span class="k">fun</span> () <span class="k">-&gt;</span>
    <span onmouseout="hideTip(event, 'ft45', 123)" onmouseover="showTip(event, 'ft45', 123)" class="i">parse</span><span class="o">.</span><span onmouseout="hideTip(event, 'ft53', 124)" onmouseover="showTip(event, 'ft53', 124)" class="i">Bind</span>(<span onmouseout="hideTip(event, 'ft47', 125)" onmouseover="showTip(event, 'ft47', 125)" class="i">p</span>, <span class="k">fun</span> <span onmouseout="hideTip(event, 'ft48', 126)" onmouseover="showTip(event, 'ft48', 126)" class="i">x</span> <span class="k">-&gt;</span>
      <span onmouseout="hideTip(event, 'ft45', 127)" onmouseover="showTip(event, 'ft45', 127)" class="i">parse</span><span class="o">.</span><span onmouseout="hideTip(event, 'ft53', 128)" onmouseover="showTip(event, 'ft53', 128)" class="i">Bind</span>(<span onmouseout="hideTip(event, 'ft54', 129)" onmouseover="showTip(event, 'ft54', 129)" class="i">zeroOrMore</span> <span onmouseout="hideTip(event, 'ft47', 130)" onmouseover="showTip(event, 'ft47', 130)" class="i">p</span>, <span class="k">fun</span> <span onmouseout="hideTip(event, 'ft49', 131)" onmouseover="showTip(event, 'ft49', 131)" class="i">xs</span> <span class="k">-&gt;</span>
        <span onmouseout="hideTip(event, 'ft45', 132)" onmouseover="showTip(event, 'ft45', 132)" class="i">parse</span><span class="o">.</span><span onmouseout="hideTip(event, 'ft55', 133)" onmouseover="showTip(event, 'ft55', 133)" class="i">Return</span>(<span onmouseout="hideTip(event, 'ft48', 134)" onmouseover="showTip(event, 'ft48', 134)" class="i">x</span><span class="o">::</span><span onmouseout="hideTip(event, 'ft49', 135)" onmouseover="showTip(event, 'ft49', 135)" class="i">xs</span>))))

<span class="k">and</span> <span onmouseout="hideTip(event, 'ft54', 136)" onmouseover="showTip(event, 'ft54', 136)" class="i">zeroOrMore</span> <span onmouseout="hideTip(event, 'ft47', 137)" onmouseover="showTip(event, 'ft47', 137)" class="i">p</span> <span class="o">=</span> 
  <span onmouseout="hideTip(event, 'ft45', 138)" onmouseover="showTip(event, 'ft45', 138)" class="i">parse</span><span class="o">.</span><span onmouseout="hideTip(event, 'ft52', 139)" onmouseover="showTip(event, 'ft52', 139)" class="i">Delay</span>(<span class="k">fun</span> () <span class="k">-&gt;</span>
    <span onmouseout="hideTip(event, 'ft45', 140)" onmouseover="showTip(event, 'ft45', 140)" class="i">parse</span><span class="o">.</span><span onmouseout="hideTip(event, 'ft56', 141)" onmouseover="showTip(event, 'ft56', 141)" class="i">Combine</span>
      ( <span onmouseout="hideTip(event, 'ft45', 142)" onmouseover="showTip(event, 'ft45', 142)" class="i">parse</span><span class="o">.</span><span onmouseout="hideTip(event, 'ft57', 143)" onmouseover="showTip(event, 'ft57', 143)" class="i">ReturnFrom</span>(<span onmouseout="hideTip(event, 'ft51', 144)" onmouseover="showTip(event, 'ft51', 144)" class="i">oneOrMore</span> <span onmouseout="hideTip(event, 'ft47', 145)" onmouseover="showTip(event, 'ft47', 145)" class="i">p</span>),
        <span onmouseout="hideTip(event, 'ft45', 146)" onmouseover="showTip(event, 'ft45', 146)" class="i">parse</span><span class="o">.</span><span onmouseout="hideTip(event, 'ft52', 147)" onmouseover="showTip(event, 'ft52', 147)" class="i">Delay</span>(<span class="k">fun</span> () <span class="k">-&gt;</span> <span onmouseout="hideTip(event, 'ft45', 148)" onmouseover="showTip(event, 'ft45', 148)" class="i">parse</span><span class="o">.</span><span onmouseout="hideTip(event, 'ft55', 149)" onmouseover="showTip(event, 'ft55', 149)" class="i">Return</span>([])) ))</pre>


<p>To run the sample parsers defined earlier, we need to add a number of primitive parsers.
In the following snippet, <code>sat</code> parses a single character if it matches a given predicate
and <code>letter</code> with <code>number</code> parse individual letter or numeric symbol, respectively:</p>

<pre class="fssnip runnable">
<span class="c">/// Primitive parser that parses a char if it matches a predicate</span>
<span class="k">let</span> <span onmouseout="hideTip(event, 'ft58', 150)" onmouseover="showTip(event, 'ft58', 150)" class="i">sat</span> <span onmouseout="hideTip(event, 'ft59', 151)" onmouseover="showTip(event, 'ft59', 151)" class="i">f</span> <span class="o">=</span> <span id="ftt60" onmouseout="hideTip(event, 'ft60', 152)" onmouseover="showTip(event, 'ft60', 152, document.getElementById('ftt60'))" class="omitted">(...)</span>
<span class="c">// Parsers that recognize single letter and number</span>
<span class="k">let</span> <span onmouseout="hideTip(event, 'ft61', 153)" onmouseover="showTip(event, 'ft61', 153)" class="i">letter</span> <span class="o">=</span> <span onmouseout="hideTip(event, 'ft58', 154)" onmouseover="showTip(event, 'ft58', 154)" class="i">sat</span> <span onmouseout="hideTip(event, 'ft62', 155)" onmouseover="showTip(event, 'ft62', 155)" class="i">System</span><span class="o">.</span><span onmouseout="hideTip(event, 'ft63', 156)" onmouseover="showTip(event, 'ft63', 156)" class="i">Char</span><span class="o">.</span><span onmouseout="hideTip(event, 'ft64', 157)" onmouseover="showTip(event, 'ft64', 157)" class="i">IsLetter</span>
<span class="k">let</span> <span onmouseout="hideTip(event, 'ft65', 158)" onmouseover="showTip(event, 'ft65', 158)" class="i">number</span> <span class="o">=</span> <span onmouseout="hideTip(event, 'ft58', 159)" onmouseover="showTip(event, 'ft58', 159)" class="i">sat</span> <span onmouseout="hideTip(event, 'ft62', 160)" onmouseover="showTip(event, 'ft62', 160)" class="i">System</span><span class="o">.</span><span onmouseout="hideTip(event, 'ft63', 161)" onmouseover="showTip(event, 'ft63', 161)" class="i">Char</span><span class="o">.</span><span onmouseout="hideTip(event, 'ft66', 162)" onmouseover="showTip(event, 'ft66', 162)" class="i">IsNumber</span>

<span class="c">// Examples: Parse one or more &amp; zero or more numbers</span>
<span onmouseout="hideTip(event, 'ft6', 163)" onmouseover="showTip(event, 'ft6', 163)" class="i">run</span> (<span onmouseout="hideTip(event, 'ft46', 164)" onmouseover="showTip(event, 'ft46', 164)" class="i">oneOrMore</span> <span onmouseout="hideTip(event, 'ft65', 165)" onmouseover="showTip(event, 'ft65', 165)" class="i">number</span>) <span class="s">&quot;</span><span class="s">hi</span><span class="s">&quot;</span>
<span onmouseout="hideTip(event, 'ft6', 166)" onmouseover="showTip(event, 'ft6', 166)" class="i">run</span> (<span onmouseout="hideTip(event, 'ft46', 167)" onmouseover="showTip(event, 'ft46', 167)" class="i">oneOrMore</span> <span onmouseout="hideTip(event, 'ft65', 168)" onmouseover="showTip(event, 'ft65', 168)" class="i">number</span>) <span class="s">&quot;</span><span class="s">123</span><span class="s">&quot;</span>
<span onmouseout="hideTip(event, 'ft6', 169)" onmouseover="showTip(event, 'ft6', 169)" class="i">run</span> (<span onmouseout="hideTip(event, 'ft50', 170)" onmouseover="showTip(event, 'ft50', 170)" class="i">zeroOrMore</span> <span onmouseout="hideTip(event, 'ft65', 171)" onmouseover="showTip(event, 'ft65', 171)" class="i">number</span>) <span class="s">&quot;</span><span class="s">hi</span><span class="s">&quot;</span>
<span onmouseout="hideTip(event, 'ft6', 172)" onmouseover="showTip(event, 'ft6', 172)" class="i">run</span> (<span onmouseout="hideTip(event, 'ft50', 173)" onmouseover="showTip(event, 'ft50', 173)" class="i">zeroOrMore</span> <span onmouseout="hideTip(event, 'ft65', 174)" onmouseover="showTip(event, 'ft65', 174)" class="i">number</span>) <span class="s">&quot;</span><span class="s">123</span><span class="s">&quot;</span><br /><button class="load" onclick='parent.loadCode("/// Primitive parser that parses a char if it matches a predicate\r\nlet sat f = (*[omit:(...)]*)P (fun buffer -\u003e seq { \r\n  match buffer with \r\n  | x::xs when f x -\u003e yield x, xs \r\n  | _ -\u003e () })(*[/omit]*)\r\n// Parsers that recognize single letter and number\r\nlet letter = sat System.Char.IsLetter\r\nlet number = sat System.Char.IsNumber\r\n\r\n// Examples: Parse one or more \u0026 zero or more numbers\r\nrun (oneOrMore number) \"hi\"\r\nrun (oneOrMore number) \"123\"\r\nrun (zeroOrMore number) \"hi\"\r\nrun (zeroOrMore number) \"123\"");'></button></pre>


<p>The last four lines can be evalauted to demonstrate the behaviour of <code>oneOrMore</code> and <code>zeroOrMore</code>.
The first one fails when given "hi", because that string does not start with any number. 
On the other hand, <code>zeroOrMore</code> succeeds, returning an empty list (of parsed numeric characters)
as the result.</p>

<p>We could extend the <code>parse</code> computation a bit further, but that is beyond the scope of this 
online appendix. In particular, it would be possible to provide <code>for</code> and <code>while</code> loops in a 
standard fashion (similarly to monads) in order to write parsers that consume some parser in 
a loop. This would give us an elegant way to parse, for example, constant number of repetitions.</p>

<h2><a name="seq">Computation builder for sequences</a></h2>

<p>Other examples of a computation that matches the <em>additive monad</em> pattern are lists, sequences
and other collections. The built-in computation builder <code>seq { .. }</code> can be viewed as an instance
of this structure, but it uses quite different syntax. This is the case, because sequences
emphasize the monoidal structure (which uses the <code>yield</code> keyword) in favor of the monadic 
structure (using <code>let!</code> and <code>return</code>). The standard operations for the <code>seq&lt;'T&gt;</code> type 
can be defined as follows (here, we use the same naming as in the previous example):</p>

<pre class="fssnip runnable">
<span class="k">module</span> <span class="i">Sequence</span> <span class="o">=</span> 
  <span class="c">/// Returns a singleton sequence containing just &#39;v&#39;</span>
  <span class="k">let</span> <span onmouseout="hideTip(event, 'ft67', 175)" onmouseover="showTip(event, 'ft67', 175)" class="i">unit</span> <span onmouseout="hideTip(event, 'ft16', 176)" onmouseover="showTip(event, 'ft16', 176)" class="i">v</span> <span class="o">=</span> <span onmouseout="hideTip(event, 'ft10', 177)" onmouseover="showTip(event, 'ft10', 177)" class="i">Seq</span><span class="o">.</span><span onmouseout="hideTip(event, 'ft68', 178)" onmouseover="showTip(event, 'ft68', 178)" class="i">singleton</span> <span onmouseout="hideTip(event, 'ft16', 179)" onmouseover="showTip(event, 'ft16', 179)" class="i">v</span> 
  <span class="c">/// Apply &#39;f&#39; to all elements and concatenate generated sequences</span>
  <span class="k">let</span> <span onmouseout="hideTip(event, 'ft69', 180)" onmouseover="showTip(event, 'ft69', 180)" class="i">bind</span> <span onmouseout="hideTip(event, 'ft70', 181)" onmouseover="showTip(event, 'ft70', 181)" class="i">f</span> <span onmouseout="hideTip(event, 'ft71', 182)" onmouseover="showTip(event, 'ft71', 182)" class="i">s</span> <span class="o">=</span> <span onmouseout="hideTip(event, 'ft71', 183)" onmouseover="showTip(event, 'ft71', 183)" class="i">s</span> <span class="o">|&gt;</span> <span onmouseout="hideTip(event, 'ft10', 184)" onmouseover="showTip(event, 'ft10', 184)" class="i">Seq</span><span class="o">.</span><span onmouseout="hideTip(event, 'ft11', 185)" onmouseover="showTip(event, 'ft11', 185)" class="i">map</span> <span onmouseout="hideTip(event, 'ft70', 186)" onmouseover="showTip(event, 'ft70', 186)" class="i">f</span> <span class="o">|&gt;</span> <span onmouseout="hideTip(event, 'ft10', 187)" onmouseover="showTip(event, 'ft10', 187)" class="i">Seq</span><span class="o">.</span><span onmouseout="hideTip(event, 'ft26', 188)" onmouseover="showTip(event, 'ft26', 188)" class="i">concat</span>
  <span class="c">/// Concatenate elements of two sequences</span>
  <span class="k">let</span> <span onmouseout="hideTip(event, 'ft72', 189)" onmouseover="showTip(event, 'ft72', 189)" class="i">combine</span> <span onmouseout="hideTip(event, 'ft73', 190)" onmouseover="showTip(event, 'ft73', 190)" class="i">s1</span> <span onmouseout="hideTip(event, 'ft74', 191)" onmouseover="showTip(event, 'ft74', 191)" class="i">s2</span> <span class="o">=</span> <span onmouseout="hideTip(event, 'ft10', 192)" onmouseover="showTip(event, 'ft10', 192)" class="i">Seq</span><span class="o">.</span><span onmouseout="hideTip(event, 'ft26', 193)" onmouseover="showTip(event, 'ft26', 193)" class="i">concat</span> [ <span onmouseout="hideTip(event, 'ft73', 194)" onmouseover="showTip(event, 'ft73', 194)" class="i">s1</span>; <span onmouseout="hideTip(event, 'ft74', 195)" onmouseover="showTip(event, 'ft74', 195)" class="i">s2</span> ]
  <span class="c">/// Returns an empty sequence</span>
  <span class="k">let</span> <span onmouseout="hideTip(event, 'ft75', 196)" onmouseover="showTip(event, 'ft75', 196)" class="i">zero</span> () <span class="o">=</span> <span onmouseout="hideTip(event, 'ft10', 197)" onmouseover="showTip(event, 'ft10', 197)" class="i">Seq</span><span class="o">.</span><span onmouseout="hideTip(event, 'ft23', 198)" onmouseover="showTip(event, 'ft23', 198)" class="i">empty</span><br /><button class="run" onclick='parent.runCode("module Sequence = \r\n  /// Returns a singleton sequence containing just \u0027v\u0027\r\n  let unit v = Seq.singleton v \r\n  /// Apply \u0027f\u0027 to all elements and concatenate generated sequences\r\n  let bind f s = s |\u003e Seq.map f |\u003e Seq.concat\r\n  /// Concatenate elements of two sequences\r\n  let combine s1 s2 = Seq.concat [ s1; s2 ]\r\n  /// Returns an empty sequence\r\n  let zero () = Seq.empty");'></button></pre>


<p>The computation builder uses <code>unit</code> in the definition of the <code>Yield</code> member (and it also
defines <code>YieldFrom</code> instead of <code>ReturnFrom</code> to enable the <code>yield!</code> keyword). For sequences,
the type of the standard control flow construct <code>for</code> overlaps with the type of <code>let!</code> (bind)
and so we implement <code>For</code> using <code>bind</code> in order to make the computation builder easier to use:</p>

<pre class="fssnip runnable">
<span class="c">/// Computation builder for working with sequences</span>
<span class="k">type</span> <span onmouseout="hideTip(event, 'ft76', 199)" onmouseover="showTip(event, 'ft76', 199)" class="i">SeqBuilder</span>() <span class="o">=</span> 
  <span class="k">member</span> <span onmouseout="hideTip(event, 'ft77', 200)" onmouseover="showTip(event, 'ft77', 200)" class="i">x</span><span class="o">.</span><span onmouseout="hideTip(event, 'ft78', 201)" onmouseover="showTip(event, 'ft78', 201)" class="i">Yield</span>(<span onmouseout="hideTip(event, 'ft79', 202)" onmouseover="showTip(event, 'ft79', 202)" class="i">v</span>) <span class="o">=</span> <span onmouseout="hideTip(event, 'ft80', 203)" onmouseover="showTip(event, 'ft80', 203)" class="i">Sequence</span><span class="o">.</span><span onmouseout="hideTip(event, 'ft81', 204)" onmouseover="showTip(event, 'ft81', 204)" class="i">unit</span> <span onmouseout="hideTip(event, 'ft79', 205)" onmouseover="showTip(event, 'ft79', 205)" class="i">v</span>
  <span class="k">member</span> <span onmouseout="hideTip(event, 'ft77', 206)" onmouseover="showTip(event, 'ft77', 206)" class="i">x</span><span class="o">.</span><span onmouseout="hideTip(event, 'ft82', 207)" onmouseover="showTip(event, 'ft82', 207)" class="i">YieldFrom</span>(<span onmouseout="hideTip(event, 'ft83', 208)" onmouseover="showTip(event, 'ft83', 208)" class="i">m</span>) <span class="o">=</span> <span onmouseout="hideTip(event, 'ft83', 209)" onmouseover="showTip(event, 'ft83', 209)" class="i">m</span>
  <span class="k">member</span> <span onmouseout="hideTip(event, 'ft77', 210)" onmouseover="showTip(event, 'ft77', 210)" class="i">x</span><span class="o">.</span><span onmouseout="hideTip(event, 'ft84', 211)" onmouseover="showTip(event, 'ft84', 211)" class="i">For</span>(<span onmouseout="hideTip(event, 'ft85', 212)" onmouseover="showTip(event, 'ft85', 212)" class="i">v</span>, <span onmouseout="hideTip(event, 'ft86', 213)" onmouseover="showTip(event, 'ft86', 213)" class="i">f</span>) <span class="o">=</span> <span onmouseout="hideTip(event, 'ft80', 214)" onmouseover="showTip(event, 'ft80', 214)" class="i">Sequence</span><span class="o">.</span><span onmouseout="hideTip(event, 'ft69', 215)" onmouseover="showTip(event, 'ft69', 215)" class="i">bind</span> <span onmouseout="hideTip(event, 'ft86', 216)" onmouseover="showTip(event, 'ft86', 216)" class="i">f</span> <span onmouseout="hideTip(event, 'ft85', 217)" onmouseover="showTip(event, 'ft85', 217)" class="i">v</span>
  <span class="k">member</span> <span onmouseout="hideTip(event, 'ft77', 218)" onmouseover="showTip(event, 'ft77', 218)" class="i">x</span><span class="o">.</span><span onmouseout="hideTip(event, 'ft87', 219)" onmouseover="showTip(event, 'ft87', 219)" class="i">Zero</span>() <span class="o">=</span> <span onmouseout="hideTip(event, 'ft80', 220)" onmouseover="showTip(event, 'ft80', 220)" class="i">Sequence</span><span class="o">.</span><span onmouseout="hideTip(event, 'ft75', 221)" onmouseover="showTip(event, 'ft75', 221)" class="i">zero</span>()
  <span class="k">member</span> <span onmouseout="hideTip(event, 'ft77', 222)" onmouseover="showTip(event, 'ft77', 222)" class="i">x</span><span class="o">.</span><span onmouseout="hideTip(event, 'ft88', 223)" onmouseover="showTip(event, 'ft88', 223)" class="i">Combine</span>(<span onmouseout="hideTip(event, 'ft89', 224)" onmouseover="showTip(event, 'ft89', 224)" class="i">p1</span>, <span onmouseout="hideTip(event, 'ft90', 225)" onmouseover="showTip(event, 'ft90', 225)" class="i">p2</span>) <span class="o">=</span> <span onmouseout="hideTip(event, 'ft80', 226)" onmouseover="showTip(event, 'ft80', 226)" class="i">Sequence</span><span class="o">.</span><span onmouseout="hideTip(event, 'ft72', 227)" onmouseover="showTip(event, 'ft72', 227)" class="i">combine</span> <span onmouseout="hideTip(event, 'ft89', 228)" onmouseover="showTip(event, 'ft89', 228)" class="i">p1</span> <span onmouseout="hideTip(event, 'ft90', 229)" onmouseover="showTip(event, 'ft90', 229)" class="i">p2</span>
  <span class="k">member</span> <span onmouseout="hideTip(event, 'ft77', 230)" onmouseover="showTip(event, 'ft77', 230)" class="i">x</span><span class="o">.</span><span onmouseout="hideTip(event, 'ft91', 231)" onmouseover="showTip(event, 'ft91', 231)" class="i">Delay</span>(<span onmouseout="hideTip(event, 'ft92', 232)" onmouseover="showTip(event, 'ft92', 232)" class="i">f</span>) <span class="o">=</span> <span onmouseout="hideTip(event, 'ft10', 233)" onmouseover="showTip(event, 'ft10', 233)" class="i">Seq</span><span class="o">.</span><span onmouseout="hideTip(event, 'ft93', 234)" onmouseover="showTip(event, 'ft93', 234)" class="i">delay</span> <span onmouseout="hideTip(event, 'ft92', 235)" onmouseover="showTip(event, 'ft92', 235)" class="i">f</span>

<span class="c">/// A unique instance of the computation builder</span>
<span class="k">let</span> <span onmouseout="hideTip(event, 'ft94', 236)" onmouseover="showTip(event, 'ft94', 236)" class="i">sq</span> <span class="o">=</span> <span onmouseout="hideTip(event, 'ft76', 237)" onmouseover="showTip(event, 'ft76', 237)" class="i">SeqBuilder</span>()<br /><button class="run" onclick='parent.runCode("/// Computation builder for working with sequences\r\ntype SeqBuilder() = \r\n  member x.Yield(v) = Sequence.unit v\r\n  member x.YieldFrom(m) = m\r\n  member x.For(v, f) = Sequence.bind f v\r\n  member x.Zero() = Sequence.zero()\r\n  member x.Combine(p1, p2) = Sequence.combine p1 p2\r\n  member x.Delay(f) = Seq.delay f\r\n\r\n/// A unique instance of the computation builder\r\nlet sq = SeqBuilder()");'></button></pre>


<p>Just like parsers, sequences can capture untracked F# effects, so the type of delayed computations
is also <code>seq&lt;'T&gt;</code>. The <code>Delay</code> member can be implemented using a standard library function
<code>Seq.delay</code>.</p>

<h3>Programming with sequences</h3>

<p>The following example shows how to generate a sequence of Fibonacci numbers using the
computation builder:</p>

<pre class="fssnip runnable">
<span class="k">let</span> <span class="k">rec</span> <span onmouseout="hideTip(event, 'ft95', 238)" onmouseover="showTip(event, 'ft95', 238)" class="i">fibs</span> <span class="o">=</span> 
  <span onmouseout="hideTip(event, 'ft94', 239)" onmouseover="showTip(event, 'ft94', 239)" class="i">sq</span> { <span class="c">// Yield the first two elements</span>
       <span class="k">yield!</span> <span onmouseout="hideTip(event, 'ft5', 240)" onmouseover="showTip(event, 'ft5', 240)" class="i">seq</span> [<span class="n">1</span>; <span class="n">1</span>]
       <span class="c">// Generate by adding previous and pre-previous numbers</span>
       <span class="k">for</span> <span onmouseout="hideTip(event, 'ft96', 241)" onmouseover="showTip(event, 'ft96', 241)" class="i">a</span>, <span onmouseout="hideTip(event, 'ft97', 242)" onmouseover="showTip(event, 'ft97', 242)" class="i">b</span> <span class="k">in</span> <span onmouseout="hideTip(event, 'ft10', 243)" onmouseover="showTip(event, 'ft10', 243)" class="i">Seq</span><span class="o">.</span><span onmouseout="hideTip(event, 'ft98', 244)" onmouseover="showTip(event, 'ft98', 244)" class="i">zip</span> <span onmouseout="hideTip(event, 'ft95', 245)" onmouseover="showTip(event, 'ft95', 245)" class="i">fibs</span> (<span onmouseout="hideTip(event, 'ft10', 246)" onmouseover="showTip(event, 'ft10', 246)" class="i">Seq</span><span class="o">.</span><span onmouseout="hideTip(event, 'ft99', 247)" onmouseover="showTip(event, 'ft99', 247)" class="i">skip</span> <span class="n">1</span> <span onmouseout="hideTip(event, 'ft95', 248)" onmouseover="showTip(event, 'ft95', 248)" class="i">fibs</span>) <span class="k">do</span>
         <span class="k">yield</span> <span onmouseout="hideTip(event, 'ft96', 249)" onmouseover="showTip(event, 'ft96', 249)" class="i">a</span> <span class="o">+</span> <span onmouseout="hideTip(event, 'ft97', 250)" onmouseover="showTip(event, 'ft97', 250)" class="i">b</span> }

<span class="c">// Run this code to generate a sample sequence</span>
<span onmouseout="hideTip(event, 'ft95', 251)" onmouseover="showTip(event, 'ft95', 251)" class="i">fibs</span> <span class="o">|&gt;</span> <span onmouseout="hideTip(event, 'ft10', 252)" onmouseover="showTip(event, 'ft10', 252)" class="i">Seq</span><span class="o">.</span><span onmouseout="hideTip(event, 'ft100', 253)" onmouseover="showTip(event, 'ft100', 253)" class="i">take</span> <span class="n">12</span> <span class="o">|&gt;</span> <span onmouseout="hideTip(event, 'ft8', 254)" onmouseover="showTip(event, 'ft8', 254)" class="i">List</span><span class="o">.</span><span onmouseout="hideTip(event, 'ft9', 255)" onmouseover="showTip(event, 'ft9', 255)" class="i">ofSeq</span><br /><button class="load" onclick='parent.loadCode("let rec fibs = \r\n  sq { // Yield the first two elements\r\n       yield! seq [1; 1]\r\n       // Generate by adding previous and pre-previous numbers\r\n       for a, b in Seq.zip fibs (Seq.skip 1 fibs) do\r\n         yield a + b }\r\n\r\n// Run this code to generate a sample sequence\r\nfibs |\u003e Seq.take 12 |\u003e List.ofSeq");'></button></pre>


<p>The translated code combines both monadic and monoidal operations. The operation <code>Combine</code> is used
to combine the first two elements of the sequence with the rest of the sequence generated by <code>for</code>.
The <code>for</code> keyword corresponds to monadic bind (although exposed as the <code>For</code> member) and it performs
a simple <em>map</em> operation over a sequence:</p>

<pre class="fssnip">
<span class="k">let</span> <span class="k">rec</span> <span onmouseout="hideTip(event, 'ft101', 256)" onmouseover="showTip(event, 'ft101', 256)" class="i">fibs</span> <span class="o">=</span> 
  <span onmouseout="hideTip(event, 'ft94', 257)" onmouseover="showTip(event, 'ft94', 257)" class="i">sq</span><span class="o">.</span><span onmouseout="hideTip(event, 'ft102', 258)" onmouseover="showTip(event, 'ft102', 258)" class="i">Delay</span>(<span class="k">fun</span> () <span class="k">-&gt;</span>
    <span onmouseout="hideTip(event, 'ft94', 259)" onmouseover="showTip(event, 'ft94', 259)" class="i">sq</span><span class="o">.</span><span onmouseout="hideTip(event, 'ft103', 260)" onmouseover="showTip(event, 'ft103', 260)" class="i">Combine</span>
      ( <span onmouseout="hideTip(event, 'ft94', 261)" onmouseover="showTip(event, 'ft94', 261)" class="i">sq</span><span class="o">.</span><span onmouseout="hideTip(event, 'ft104', 262)" onmouseover="showTip(event, 'ft104', 262)" class="i">YieldFrom</span>( <span onmouseout="hideTip(event, 'ft5', 263)" onmouseover="showTip(event, 'ft5', 263)" class="i">seq</span> [<span class="n">1</span>; <span class="n">1</span>] ),
        <span onmouseout="hideTip(event, 'ft94', 264)" onmouseover="showTip(event, 'ft94', 264)" class="i">sq</span><span class="o">.</span><span onmouseout="hideTip(event, 'ft102', 265)" onmouseover="showTip(event, 'ft102', 265)" class="i">Delay</span>(<span class="k">fun</span> () <span class="k">-&gt;</span>
          <span onmouseout="hideTip(event, 'ft94', 266)" onmouseover="showTip(event, 'ft94', 266)" class="i">sq</span><span class="o">.</span><span onmouseout="hideTip(event, 'ft105', 267)" onmouseover="showTip(event, 'ft105', 267)" class="i">For</span>(<span onmouseout="hideTip(event, 'ft10', 268)" onmouseover="showTip(event, 'ft10', 268)" class="i">Seq</span><span class="o">.</span><span onmouseout="hideTip(event, 'ft98', 269)" onmouseover="showTip(event, 'ft98', 269)" class="i">zip</span> <span onmouseout="hideTip(event, 'ft101', 270)" onmouseover="showTip(event, 'ft101', 270)" class="i">fibs</span> (<span onmouseout="hideTip(event, 'ft10', 271)" onmouseover="showTip(event, 'ft10', 271)" class="i">Seq</span><span class="o">.</span><span onmouseout="hideTip(event, 'ft99', 272)" onmouseover="showTip(event, 'ft99', 272)" class="i">skip</span> <span class="n">1</span> <span onmouseout="hideTip(event, 'ft101', 273)" onmouseover="showTip(event, 'ft101', 273)" class="i">fibs</span>), <span class="k">fun</span> (<span onmouseout="hideTip(event, 'ft96', 274)" onmouseover="showTip(event, 'ft96', 274)" class="i">a</span>, <span onmouseout="hideTip(event, 'ft97', 275)" onmouseover="showTip(event, 'ft97', 275)" class="i">b</span>) <span class="k">-&gt;</span>
            <span onmouseout="hideTip(event, 'ft94', 276)" onmouseover="showTip(event, 'ft94', 276)" class="i">sq</span><span class="o">.</span><span onmouseout="hideTip(event, 'ft106', 277)" onmouseover="showTip(event, 'ft106', 277)" class="i">Yield</span>(<span onmouseout="hideTip(event, 'ft96', 278)" onmouseover="showTip(event, 'ft96', 278)" class="i">a</span> <span class="o">+</span> <span onmouseout="hideTip(event, 'ft97', 279)" onmouseover="showTip(event, 'ft97', 279)" class="i">b</span>))) ))</pre>


<h2>Additive monad laws</h2>

<p>To conclude, additive monads also obey a set of laws. Although these are less widely known (and standardized)
than for monads or monoids, they form an important component of the interface. They can be expressed in 
terms of both notations that were used above - we use the first one that is, arguably, more standard.
As expected, the laws overlap with the laws that were discussed earlier about monads and monoids:</p>

<pre class="fssnip">
<span class="c">/// The associativity monoid law </span>
<span class="k">let</span> <span onmouseout="hideTip(event, 'ft112', 288)" onmouseover="showTip(event, 'ft112', 288)" class="i">monoidAssociativity</span> <span onmouseout="hideTip(event, 'ft113', 289)" onmouseover="showTip(event, 'ft113', 289)" class="i">n1</span> <span onmouseout="hideTip(event, 'ft114', 290)" onmouseover="showTip(event, 'ft114', 290)" class="i">n2</span> <span onmouseout="hideTip(event, 'ft115', 291)" onmouseover="showTip(event, 'ft115', 291)" class="i">n3</span> <span class="o">=</span>
  <span class="k">let</span> <span onmouseout="hideTip(event, 'ft116', 292)" onmouseover="showTip(event, 'ft116', 292)" class="i">m1</span> <span class="o">=</span> <span onmouseout="hideTip(event, 'ft107', 293)" onmouseover="showTip(event, 'ft107', 293)" class="i">m</span> { <span class="k">return!</span> <span onmouseout="hideTip(event, 'ft113', 294)" onmouseover="showTip(event, 'ft113', 294)" class="i">n1</span> 
               <span class="k">return!</span> <span onmouseout="hideTip(event, 'ft114', 295)" onmouseover="showTip(event, 'ft114', 295)" class="i">n2</span>
               <span class="k">return!</span> <span onmouseout="hideTip(event, 'ft115', 296)" onmouseover="showTip(event, 'ft115', 296)" class="i">n3</span> }
  <span class="k">let</span> <span onmouseout="hideTip(event, 'ft117', 297)" onmouseover="showTip(event, 'ft117', 297)" class="i">m2</span> <span class="o">=</span> <span onmouseout="hideTip(event, 'ft107', 298)" onmouseover="showTip(event, 'ft107', 298)" class="i">m</span> { <span class="k">return!</span> <span onmouseout="hideTip(event, 'ft107', 299)" onmouseover="showTip(event, 'ft107', 299)" class="i">m</span> { <span class="k">return!</span> <span onmouseout="hideTip(event, 'ft113', 300)" onmouseover="showTip(event, 'ft113', 300)" class="i">n1</span> 
                           <span class="k">return!</span> <span onmouseout="hideTip(event, 'ft114', 301)" onmouseover="showTip(event, 'ft114', 301)" class="i">n2</span> }
               <span class="k">return!</span> <span onmouseout="hideTip(event, 'ft115', 302)" onmouseover="showTip(event, 'ft115', 302)" class="i">n3</span> }
  <span onmouseout="hideTip(event, 'ft116', 303)" onmouseover="showTip(event, 'ft116', 303)" class="i">m1</span> <span class="o">|&gt;</span> <span onmouseout="hideTip(event, 'ft108', 304)" onmouseover="showTip(event, 'ft108', 304)" class="i">shouldEqual</span> <span onmouseout="hideTip(event, 'ft117', 305)" onmouseover="showTip(event, 'ft117', 305)" class="i">m2</span>

<span class="c">/// The unit monoid laws </span>
<span class="k">let</span> <span onmouseout="hideTip(event, 'ft118', 306)" onmouseover="showTip(event, 'ft118', 306)" class="i">unit</span> <span onmouseout="hideTip(event, 'ft113', 307)" onmouseover="showTip(event, 'ft113', 307)" class="i">n1</span> <span onmouseout="hideTip(event, 'ft114', 308)" onmouseover="showTip(event, 'ft114', 308)" class="i">n2</span> <span class="o">=</span>
  <span class="k">let</span> <span onmouseout="hideTip(event, 'ft116', 309)" onmouseover="showTip(event, 'ft116', 309)" class="i">m1</span> <span class="o">=</span> <span onmouseout="hideTip(event, 'ft107', 310)" onmouseover="showTip(event, 'ft107', 310)" class="i">m</span> { <span class="k">return!</span> <span onmouseout="hideTip(event, 'ft113', 311)" onmouseover="showTip(event, 'ft113', 311)" class="i">n1</span>
               <span class="k">if</span> <span class="k">false</span> <span class="k">then</span> <span class="k">return!</span> <span onmouseout="hideTip(event, 'ft114', 312)" onmouseover="showTip(event, 'ft114', 312)" class="i">n2</span> }
  <span class="k">let</span> <span onmouseout="hideTip(event, 'ft117', 313)" onmouseover="showTip(event, 'ft117', 313)" class="i">m2</span> <span class="o">=</span> <span onmouseout="hideTip(event, 'ft107', 314)" onmouseover="showTip(event, 'ft107', 314)" class="i">m</span> { <span class="k">if</span> <span class="k">false</span> <span class="k">then</span> <span class="k">return!</span> <span onmouseout="hideTip(event, 'ft114', 315)" onmouseover="showTip(event, 'ft114', 315)" class="i">n2</span>
               <span class="k">return!</span> <span onmouseout="hideTip(event, 'ft113', 316)" onmouseover="showTip(event, 'ft113', 316)" class="i">n1</span> }
  <span class="k">let</span> <span onmouseout="hideTip(event, 'ft119', 317)" onmouseover="showTip(event, 'ft119', 317)" class="i">m3</span> <span class="o">=</span> <span onmouseout="hideTip(event, 'ft107', 318)" onmouseover="showTip(event, 'ft107', 318)" class="i">m</span> { <span class="k">return!</span> <span onmouseout="hideTip(event, 'ft113', 319)" onmouseover="showTip(event, 'ft113', 319)" class="i">n1</span> }

  <span onmouseout="hideTip(event, 'ft116', 320)" onmouseover="showTip(event, 'ft116', 320)" class="i">m1</span> <span class="o">|&gt;</span> <span onmouseout="hideTip(event, 'ft108', 321)" onmouseover="showTip(event, 'ft108', 321)" class="i">shouldEqual</span> <span onmouseout="hideTip(event, 'ft119', 322)" onmouseover="showTip(event, 'ft119', 322)" class="i">m3</span>
  <span onmouseout="hideTip(event, 'ft117', 323)" onmouseover="showTip(event, 'ft117', 323)" class="i">m2</span> <span class="o">|&gt;</span> <span onmouseout="hideTip(event, 'ft108', 324)" onmouseover="showTip(event, 'ft108', 324)" class="i">shouldEqual</span> <span onmouseout="hideTip(event, 'ft119', 325)" onmouseover="showTip(event, 'ft119', 325)" class="i">m3</span>

<span class="c">/// The left identity monad law</span>
<span class="k">let</span> <span onmouseout="hideTip(event, 'ft120', 326)" onmouseover="showTip(event, 'ft120', 326)" class="i">leftIdentity</span> <span onmouseout="hideTip(event, 'ft48', 327)" onmouseover="showTip(event, 'ft48', 327)" class="i">x</span> <span onmouseout="hideTip(event, 'ft19', 328)" onmouseover="showTip(event, 'ft19', 328)" class="i">f</span> <span class="o">=</span> 
  <span class="k">let</span> <span onmouseout="hideTip(event, 'ft121', 329)" onmouseover="showTip(event, 'ft121', 329)" class="i">m1</span> <span class="o">=</span> <span onmouseout="hideTip(event, 'ft107', 330)" onmouseover="showTip(event, 'ft107', 330)" class="i">m</span> { <span class="k">let!</span> <span onmouseout="hideTip(event, 'ft16', 331)" onmouseover="showTip(event, 'ft16', 331)" class="i">v</span> <span class="o">=</span> <span onmouseout="hideTip(event, 'ft107', 332)" onmouseover="showTip(event, 'ft107', 332)" class="i">m</span> { <span class="k">return</span> <span onmouseout="hideTip(event, 'ft48', 333)" onmouseover="showTip(event, 'ft48', 333)" class="i">x</span> }
               <span class="k">return!</span> <span onmouseout="hideTip(event, 'ft19', 334)" onmouseover="showTip(event, 'ft19', 334)" class="i">f</span> <span onmouseout="hideTip(event, 'ft16', 335)" onmouseover="showTip(event, 'ft16', 335)" class="i">v</span> } 
  <span class="k">let</span> <span onmouseout="hideTip(event, 'ft122', 336)" onmouseover="showTip(event, 'ft122', 336)" class="i">m2</span> <span class="o">=</span> <span onmouseout="hideTip(event, 'ft107', 337)" onmouseover="showTip(event, 'ft107', 337)" class="i">m</span> { <span class="k">return!</span> <span onmouseout="hideTip(event, 'ft19', 338)" onmouseover="showTip(event, 'ft19', 338)" class="i">f</span> <span onmouseout="hideTip(event, 'ft48', 339)" onmouseover="showTip(event, 'ft48', 339)" class="i">x</span> }
  <span onmouseout="hideTip(event, 'ft121', 340)" onmouseover="showTip(event, 'ft121', 340)" class="i">m1</span> <span class="o">|&gt;</span> <span onmouseout="hideTip(event, 'ft108', 341)" onmouseover="showTip(event, 'ft108', 341)" class="i">shouldEqual</span> <span onmouseout="hideTip(event, 'ft122', 342)" onmouseover="showTip(event, 'ft122', 342)" class="i">m2</span>

<span class="c">/// The right identity monad law </span>
<span class="k">let</span> <span onmouseout="hideTip(event, 'ft123', 343)" onmouseover="showTip(event, 'ft123', 343)" class="i">rightIdentity</span> <span onmouseout="hideTip(event, 'ft124', 344)" onmouseover="showTip(event, 'ft124', 344)" class="i">n</span> <span class="o">=</span>
  <span class="k">let</span> <span onmouseout="hideTip(event, 'ft116', 345)" onmouseover="showTip(event, 'ft116', 345)" class="i">m1</span> <span class="o">=</span> <span onmouseout="hideTip(event, 'ft107', 346)" onmouseover="showTip(event, 'ft107', 346)" class="i">m</span> { <span class="k">let!</span> <span onmouseout="hideTip(event, 'ft48', 347)" onmouseover="showTip(event, 'ft48', 347)" class="i">x</span> <span class="o">=</span> <span onmouseout="hideTip(event, 'ft124', 348)" onmouseover="showTip(event, 'ft124', 348)" class="i">n</span> 
               <span class="k">return</span> <span onmouseout="hideTip(event, 'ft48', 349)" onmouseover="showTip(event, 'ft48', 349)" class="i">x</span> }
  <span class="k">let</span> <span onmouseout="hideTip(event, 'ft117', 350)" onmouseover="showTip(event, 'ft117', 350)" class="i">m2</span> <span class="o">=</span> <span onmouseout="hideTip(event, 'ft107', 351)" onmouseover="showTip(event, 'ft107', 351)" class="i">m</span> { <span class="k">return!</span> <span onmouseout="hideTip(event, 'ft124', 352)" onmouseover="showTip(event, 'ft124', 352)" class="i">n</span> }
  <span onmouseout="hideTip(event, 'ft116', 353)" onmouseover="showTip(event, 'ft116', 353)" class="i">m1</span> <span class="o">|&gt;</span> <span onmouseout="hideTip(event, 'ft108', 354)" onmouseover="showTip(event, 'ft108', 354)" class="i">shouldEqual</span> <span onmouseout="hideTip(event, 'ft117', 355)" onmouseover="showTip(event, 'ft117', 355)" class="i">m2</span>

<span class="c">/// The associativity monad law </span>
<span class="k">let</span> <span onmouseout="hideTip(event, 'ft125', 356)" onmouseover="showTip(event, 'ft125', 356)" class="i">monadAssociativity</span> <span onmouseout="hideTip(event, 'ft124', 357)" onmouseover="showTip(event, 'ft124', 357)" class="i">n</span> <span onmouseout="hideTip(event, 'ft126', 358)" onmouseover="showTip(event, 'ft126', 358)" class="i">f</span> <span onmouseout="hideTip(event, 'ft127', 359)" onmouseover="showTip(event, 'ft127', 359)" class="i">g</span> <span class="o">=</span>
  <span class="k">let</span> <span onmouseout="hideTip(event, 'ft121', 360)" onmouseover="showTip(event, 'ft121', 360)" class="i">m1</span> <span class="o">=</span> <span onmouseout="hideTip(event, 'ft107', 361)" onmouseover="showTip(event, 'ft107', 361)" class="i">m</span> { <span class="k">let!</span> <span onmouseout="hideTip(event, 'ft128', 362)" onmouseover="showTip(event, 'ft128', 362)" class="i">y</span> <span class="o">=</span> <span onmouseout="hideTip(event, 'ft107', 363)" onmouseover="showTip(event, 'ft107', 363)" class="i">m</span> { <span class="k">let!</span> <span onmouseout="hideTip(event, 'ft48', 364)" onmouseover="showTip(event, 'ft48', 364)" class="i">x</span> <span class="o">=</span> <span onmouseout="hideTip(event, 'ft124', 365)" onmouseover="showTip(event, 'ft124', 365)" class="i">n</span>
                            <span class="k">return!</span> <span onmouseout="hideTip(event, 'ft126', 366)" onmouseover="showTip(event, 'ft126', 366)" class="i">f</span> <span onmouseout="hideTip(event, 'ft48', 367)" onmouseover="showTip(event, 'ft48', 367)" class="i">x</span> }
               <span class="k">return!</span> <span onmouseout="hideTip(event, 'ft127', 368)" onmouseover="showTip(event, 'ft127', 368)" class="i">g</span> <span onmouseout="hideTip(event, 'ft128', 369)" onmouseover="showTip(event, 'ft128', 369)" class="i">y</span> }
  <span class="k">let</span> <span onmouseout="hideTip(event, 'ft122', 370)" onmouseover="showTip(event, 'ft122', 370)" class="i">m2</span> <span class="o">=</span> <span onmouseout="hideTip(event, 'ft107', 371)" onmouseover="showTip(event, 'ft107', 371)" class="i">m</span> { <span class="k">let!</span> <span onmouseout="hideTip(event, 'ft48', 372)" onmouseover="showTip(event, 'ft48', 372)" class="i">x</span> <span class="o">=</span> <span onmouseout="hideTip(event, 'ft124', 373)" onmouseover="showTip(event, 'ft124', 373)" class="i">n</span>
               <span class="k">return!</span> <span onmouseout="hideTip(event, 'ft107', 374)" onmouseover="showTip(event, 'ft107', 374)" class="i">m</span> { <span class="k">let!</span> <span onmouseout="hideTip(event, 'ft128', 375)" onmouseover="showTip(event, 'ft128', 375)" class="i">y</span> <span class="o">=</span> <span onmouseout="hideTip(event, 'ft126', 376)" onmouseover="showTip(event, 'ft126', 376)" class="i">f</span> <span onmouseout="hideTip(event, 'ft48', 377)" onmouseover="showTip(event, 'ft48', 377)" class="i">x</span>
                           <span class="k">return!</span> <span onmouseout="hideTip(event, 'ft127', 378)" onmouseover="showTip(event, 'ft127', 378)" class="i">g</span> <span onmouseout="hideTip(event, 'ft48', 379)" onmouseover="showTip(event, 'ft48', 379)" class="i">x</span> } }
  <span class="k">let</span> <span onmouseout="hideTip(event, 'ft129', 380)" onmouseover="showTip(event, 'ft129', 380)" class="i">m3</span> <span class="o">=</span> <span onmouseout="hideTip(event, 'ft107', 381)" onmouseover="showTip(event, 'ft107', 381)" class="i">m</span> { <span class="k">let!</span> <span onmouseout="hideTip(event, 'ft48', 382)" onmouseover="showTip(event, 'ft48', 382)" class="i">x</span> <span class="o">=</span> <span onmouseout="hideTip(event, 'ft124', 383)" onmouseover="showTip(event, 'ft124', 383)" class="i">n</span>
               <span class="k">let!</span> <span onmouseout="hideTip(event, 'ft128', 384)" onmouseover="showTip(event, 'ft128', 384)" class="i">y</span> <span class="o">=</span> <span onmouseout="hideTip(event, 'ft126', 385)" onmouseover="showTip(event, 'ft126', 385)" class="i">f</span> <span onmouseout="hideTip(event, 'ft48', 386)" onmouseover="showTip(event, 'ft48', 386)" class="i">x</span>
               <span class="k">return!</span> <span onmouseout="hideTip(event, 'ft127', 387)" onmouseover="showTip(event, 'ft127', 387)" class="i">g</span> <span onmouseout="hideTip(event, 'ft48', 388)" onmouseover="showTip(event, 'ft48', 388)" class="i">x</span> }
  <span onmouseout="hideTip(event, 'ft121', 389)" onmouseover="showTip(event, 'ft121', 389)" class="i">m1</span> <span class="o">|&gt;</span> <span onmouseout="hideTip(event, 'ft108', 390)" onmouseover="showTip(event, 'ft108', 390)" class="i">shouldEqual</span> <span onmouseout="hideTip(event, 'ft122', 391)" onmouseover="showTip(event, 'ft122', 391)" class="i">m2</span>
  <span onmouseout="hideTip(event, 'ft121', 392)" onmouseover="showTip(event, 'ft121', 392)" class="i">m1</span> <span class="o">|&gt;</span> <span onmouseout="hideTip(event, 'ft108', 393)" onmouseover="showTip(event, 'ft108', 393)" class="i">shouldEqual</span> <span onmouseout="hideTip(event, 'ft129', 394)" onmouseover="showTip(event, 'ft129', 394)" class="i">m3</span>

<span class="c">/// Left zero law of additive monads</span>
<span class="k">let</span> <span onmouseout="hideTip(event, 'ft130', 395)" onmouseover="showTip(event, 'ft130', 395)" class="i">leftZero</span> <span onmouseout="hideTip(event, 'ft113', 396)" onmouseover="showTip(event, 'ft113', 396)" class="i">n1</span> <span onmouseout="hideTip(event, 'ft131', 397)" onmouseover="showTip(event, 'ft131', 397)" class="i">k</span> <span class="o">=</span> 
  <span class="k">let</span> <span onmouseout="hideTip(event, 'ft121', 398)" onmouseover="showTip(event, 'ft121', 398)" class="i">m1</span> <span class="o">=</span> <span onmouseout="hideTip(event, 'ft107', 399)" onmouseover="showTip(event, 'ft107', 399)" class="i">m</span> { <span class="k">let!</span> <span onmouseout="hideTip(event, 'ft16', 400)" onmouseover="showTip(event, 'ft16', 400)" class="i">v</span> <span class="o">=</span> <span onmouseout="hideTip(event, 'ft107', 401)" onmouseover="showTip(event, 'ft107', 401)" class="i">m</span> { <span class="k">if</span> <span class="k">false</span> <span class="k">then</span> <span class="k">return!</span> <span onmouseout="hideTip(event, 'ft113', 402)" onmouseover="showTip(event, 'ft113', 402)" class="i">n1</span> }
               <span class="k">return!</span> <span onmouseout="hideTip(event, 'ft131', 403)" onmouseover="showTip(event, 'ft131', 403)" class="i">k</span> <span onmouseout="hideTip(event, 'ft16', 404)" onmouseover="showTip(event, 'ft16', 404)" class="i">v</span> }
  <span class="k">let</span> <span onmouseout="hideTip(event, 'ft117', 405)" onmouseover="showTip(event, 'ft117', 405)" class="i">m2</span> <span class="o">=</span> <span onmouseout="hideTip(event, 'ft107', 406)" onmouseover="showTip(event, 'ft107', 406)" class="i">m</span> { <span class="k">if</span> <span class="k">false</span> <span class="k">then</span> <span class="k">return!</span> <span onmouseout="hideTip(event, 'ft113', 407)" onmouseover="showTip(event, 'ft113', 407)" class="i">n1</span> }
  <span onmouseout="hideTip(event, 'ft121', 408)" onmouseover="showTip(event, 'ft121', 408)" class="i">m1</span> <span class="o">|&gt;</span> <span onmouseout="hideTip(event, 'ft108', 409)" onmouseover="showTip(event, 'ft108', 409)" class="i">shouldEqual</span> <span onmouseout="hideTip(event, 'ft117', 410)" onmouseover="showTip(event, 'ft117', 410)" class="i">m2</span></pre>


<p>The only law that has not been discussed previously for either <a href="monads.html">monads</a> or 
<a href="monoids.html">monoids</a> is the last law, which captures the relationship between monadic
bind and the <code>zero</code> operation. In Haskell, the law is usually expressed as
<code>mzero &gt;&gt;= k = mzero</code>.</p>

<p>The listing above includes widely accepted laws only. However, additional laws such as <em>left catch</em> and
<em>left distribution</em> (see <a href="http://www.haskell.org/haskellwiki/MonadPlus">MonadPlus page</a>) could be
expressed using the computation expression notation as well.</p>

<div class="navigation">

<p>Prev: <a href="monoids.html">Monoidal computations</a> | Next: <a href="layered.html">Layered computations</a> | <a href="home.html">Table of Contents</a></p>

</div>


    <!-- HTML for Tool Tips -->
    <div class="tip" id="ft1">type Parser&lt;&#39;T&gt; = | P of (char list -&gt; seq&lt;&#39;T * char list&gt;)<br /><br />Full name: TryJoinads.Parser&lt;_&gt;</div>
<div class="tip" id="ft2">union case Parser.P: (char list -&gt; seq&lt;&#39;T * char list&gt;) -&gt; Parser&lt;&#39;T&gt;</div>
<div class="tip" id="ft3">type &#39;T list = List&lt;&#39;T&gt;<br /><br />Full name: Microsoft.FSharp.Collections.list&lt;_&gt;<br />&#160;&#160;type: &#39;T list<br /></div>
<div class="tip" id="ft4">Multiple items<br />val char : &#39;T -&gt; char (requires member op_Explicit)<br /><br />Full name: Microsoft.FSharp.Core.Operators.char<br /><br />--------------------<br />type char = System.Char<br /><br />Full name: Microsoft.FSharp.Core.char<br />&#160;&#160;type: char<br />&#160;&#160;inherits: System.ValueType<br /></div>
<div class="tip" id="ft5">Multiple items<br />val seq : seq&lt;&#39;T&gt; -&gt; seq&lt;&#39;T&gt;<br /><br />Full name: Microsoft.FSharp.Core.Operators.seq<br /><br />--------------------<br />type seq&lt;&#39;T&gt; = System.Collections.Generic.IEnumerable&lt;&#39;T&gt;<br /><br />Full name: Microsoft.FSharp.Collections.seq&lt;_&gt;<br />&#160;&#160;type: seq&lt;&#39;T&gt;<br />&#160;&#160;inherits: System.Collections.IEnumerable<br /></div>
<div class="tip" id="ft6">val run : Parser&lt;&#39;a&gt; -&gt; (seq&lt;char&gt; -&gt; &#39;a option)<br /><br />Full name: TryJoinads.run<br /><em><br /><br />&#160;Run the parser and return the first result (or None)</em></div>
<div class="tip" id="ft7">val f : (char list -&gt; seq&lt;&#39;a * char list&gt;)</div>
<div class="tip" id="ft8">Multiple items<br />module List<br /><br />from Microsoft.FSharp.Collections<br /><br />--------------------<br />type List&lt;&#39;T&gt; =<br />&#160;&#160;| ( [] )<br />&#160;&#160;| ( :: ) of &#39;T * &#39;T list<br />&#160;&#160;with<br />&#160;&#160;&#160;&#160;interface System.Collections.IEnumerable<br />&#160;&#160;&#160;&#160;interface System.Collections.Generic.IEnumerable&lt;&#39;T&gt;<br />&#160;&#160;&#160;&#160;member Head : &#39;T<br />&#160;&#160;&#160;&#160;member IsEmpty : bool<br />&#160;&#160;&#160;&#160;member Item : index:int -&gt; &#39;T with get<br />&#160;&#160;&#160;&#160;member Length : int<br />&#160;&#160;&#160;&#160;member Tail : &#39;T list<br />&#160;&#160;&#160;&#160;static member Cons : head:&#39;T * tail:&#39;T list -&gt; &#39;T list<br />&#160;&#160;&#160;&#160;static member Empty : &#39;T list<br />&#160;&#160;end<br /><br />Full name: Microsoft.FSharp.Collections.List&lt;_&gt;<br />&#160;&#160;type: List&lt;&#39;T&gt;<br /></div>
<div class="tip" id="ft9">val ofSeq : seq&lt;&#39;T&gt; -&gt; &#39;T list<br /><br />Full name: Microsoft.FSharp.Collections.List.ofSeq</div>
<div class="tip" id="ft10">module Seq<br /><br />from Microsoft.FSharp.Collections</div>
<div class="tip" id="ft11">val map : (&#39;T -&gt; &#39;U) -&gt; seq&lt;&#39;T&gt; -&gt; seq&lt;&#39;U&gt;<br /><br />Full name: Microsoft.FSharp.Collections.Seq.map</div>
<div class="tip" id="ft12">val fst : (&#39;T1 * &#39;T2) -&gt; &#39;T1<br /><br />Full name: Microsoft.FSharp.Core.Operators.fst</div>
<div class="tip" id="ft13">val tryPick : (&#39;T -&gt; &#39;U option) -&gt; seq&lt;&#39;T&gt; -&gt; &#39;U option<br /><br />Full name: Microsoft.FSharp.Collections.Seq.tryPick</div>
<div class="tip" id="ft14">union case Option.Some: &#39;T -&gt; Option&lt;&#39;T&gt;</div>
<div class="tip" id="ft15">Multiple items<br />val unit : &#39;a -&gt; Parser&lt;&#39;a&gt;<br /><br />Full name: TryJoinads.Parsers.unit<br /><em><br /><br />&#160;Parser that succeeds without consuming any input</em><br /><br />--------------------<br />type unit = Unit<br /><br />Full name: Microsoft.FSharp.Core.unit<br />&#160;&#160;type: unit<br /></div>
<div class="tip" id="ft16">val v : &#39;a</div>
<div class="tip" id="ft17">val buffer : char list<br />&#160;&#160;type: char list<br /></div>
<div class="tip" id="ft18">val bind : (&#39;a -&gt; Parser&lt;&#39;b&gt;) -&gt; Parser&lt;&#39;a&gt; -&gt; Parser&lt;&#39;b&gt;<br /><br />Full name: TryJoinads.Parsers.bind<br /><em><br /><br />&#160;Runs the first parser and then a parser <br />&#160;generated by the provided function</em></div>
<div class="tip" id="ft19">val f : (&#39;a -&gt; Parser&lt;&#39;b&gt;)</div>
<div class="tip" id="ft20">val p1 : (char list -&gt; seq&lt;&#39;a * char list&gt;)</div>
<div class="tip" id="ft21">val p2 : (char list -&gt; seq&lt;&#39;b * char list&gt;)</div>
<div class="tip" id="ft22">val zero : unit -&gt; Parser&lt;&#39;a&gt;<br /><br />Full name: TryJoinads.Parsers.zero<br /><em><br /><br />&#160;Represents a parser that always fails</em></div>
<div class="tip" id="ft23">val empty&lt;&#39;T&gt; : seq&lt;&#39;T&gt;<br /><br />Full name: Microsoft.FSharp.Collections.Seq.empty</div>
<div class="tip" id="ft24">val combine : Parser&lt;&#39;a&gt; -&gt; Parser&lt;&#39;a&gt; -&gt; Parser&lt;&#39;a&gt;<br /><br />Full name: TryJoinads.Parsers.combine<br /><em><br /><br />&#160;Non-deterministic choice - combine all possible results</em></div>
<div class="tip" id="ft25">val p2 : (char list -&gt; seq&lt;&#39;a * char list&gt;)</div>
<div class="tip" id="ft26">val concat : seq&lt;#seq&lt;&#39;T&gt;&gt; -&gt; seq&lt;&#39;T&gt;<br /><br />Full name: Microsoft.FSharp.Collections.Seq.concat</div>
<div class="tip" id="ft27">type ParserBuilder =<br />&#160;&#160;class<br />&#160;&#160;&#160;&#160;new : unit -&gt; ParserBuilder<br />&#160;&#160;&#160;&#160;member Bind : v:Parser&lt;&#39;d&gt; * f:(&#39;d -&gt; Parser&lt;&#39;e&gt;) -&gt; Parser&lt;&#39;e&gt;<br />&#160;&#160;&#160;&#160;member Combine : p1:Parser&lt;&#39;b&gt; * p2:Parser&lt;&#39;b&gt; -&gt; Parser&lt;&#39;b&gt;<br />&#160;&#160;&#160;&#160;member Delay : f:(unit -&gt; Parser&lt;&#39;a&gt;) -&gt; Parser&lt;&#39;a&gt;<br />&#160;&#160;&#160;&#160;member Return : v:&#39;g -&gt; Parser&lt;&#39;g&gt;<br />&#160;&#160;&#160;&#160;member ReturnFrom : m:&#39;f -&gt; &#39;f<br />&#160;&#160;&#160;&#160;member Zero : unit -&gt; Parser&lt;&#39;c&gt;<br />&#160;&#160;end<br /><br />Full name: TryJoinads.ParserBuilder<br /><em><br /><br />&#160;Computation builder for working with parsers</em></div>
<div class="tip" id="ft28">val x : ParserBuilder</div>
<div class="tip" id="ft29">member ParserBuilder.Return : v:&#39;g -&gt; Parser&lt;&#39;g&gt;<br /><br />Full name: TryJoinads.ParserBuilder.Return</div>
<div class="tip" id="ft30">val v : &#39;g</div>
<div class="tip" id="ft31">module Parsers<br /><br />from TryJoinads</div>
<div class="tip" id="ft32">val unit : &#39;a -&gt; Parser&lt;&#39;a&gt;<br /><br />Full name: TryJoinads.Parsers.unit<br /><em><br /><br />&#160;Parser that succeeds without consuming any input</em></div>
<div class="tip" id="ft33">member ParserBuilder.ReturnFrom : m:&#39;f -&gt; &#39;f<br /><br />Full name: TryJoinads.ParserBuilder.ReturnFrom</div>
<div class="tip" id="ft34">val m : &#39;f</div>
<div class="tip" id="ft35">member ParserBuilder.Bind : v:Parser&lt;&#39;d&gt; * f:(&#39;d -&gt; Parser&lt;&#39;e&gt;) -&gt; Parser&lt;&#39;e&gt;<br /><br />Full name: TryJoinads.ParserBuilder.Bind</div>
<div class="tip" id="ft36">val v : Parser&lt;&#39;d&gt;</div>
<div class="tip" id="ft37">val f : (&#39;d -&gt; Parser&lt;&#39;e&gt;)</div>
<div class="tip" id="ft38">member ParserBuilder.Zero : unit -&gt; Parser&lt;&#39;c&gt;<br /><br />Full name: TryJoinads.ParserBuilder.Zero</div>
<div class="tip" id="ft39">member ParserBuilder.Combine : p1:Parser&lt;&#39;b&gt; * p2:Parser&lt;&#39;b&gt; -&gt; Parser&lt;&#39;b&gt;<br /><br />Full name: TryJoinads.ParserBuilder.Combine</div>
<div class="tip" id="ft40">val p1 : Parser&lt;&#39;b&gt;</div>
<div class="tip" id="ft41">val p2 : Parser&lt;&#39;b&gt;</div>
<div class="tip" id="ft42">member ParserBuilder.Delay : f:(unit -&gt; Parser&lt;&#39;a&gt;) -&gt; Parser&lt;&#39;a&gt;<br /><br />Full name: TryJoinads.ParserBuilder.Delay</div>
<div class="tip" id="ft43">val f : (unit -&gt; Parser&lt;&#39;a&gt;)</div>
<div class="tip" id="ft44">val op : (char list -&gt; seq&lt;&#39;a * char list&gt;)</div>
<div class="tip" id="ft45">val parse : ParserBuilder<br /><br />Full name: TryJoinads.parse<br /><em><br /><br />&#160;A unique instance of the computation builder</em></div>
<div class="tip" id="ft46">val oneOrMore : Parser&lt;&#39;a&gt; -&gt; Parser&lt;&#39;a list&gt;<br /><br />Full name: TryJoinads.oneOrMore<br /><em><br /><br />&#160;Parse one or more occurrences of &#39;p&#39;</em></div>
<div class="tip" id="ft47">val p : Parser&lt;&#39;a&gt;</div>
<div class="tip" id="ft48">val x : &#39;a</div>
<div class="tip" id="ft49">val xs : &#39;a list<br />&#160;&#160;type: &#39;a list<br /></div>
<div class="tip" id="ft50">val zeroOrMore : Parser&lt;&#39;a&gt; -&gt; Parser&lt;&#39;a list&gt;<br /><br />Full name: TryJoinads.zeroOrMore<br /><em><br /><br />&#160;Parse zero or more occurrences of &#39;p&#39;</em></div>
<div class="tip" id="ft51">val oneOrMore : Parser&lt;&#39;a&gt; -&gt; Parser&lt;&#39;a list&gt;<br /><br />Full name: TryJoinads.ParseTranslation.oneOrMore</div>
<div class="tip" id="ft52">member ParserBuilder.Delay : f:(unit -&gt; Parser&lt;&#39;a&gt;) -&gt; Parser&lt;&#39;a&gt;</div>
<div class="tip" id="ft53">member ParserBuilder.Bind : v:Parser&lt;&#39;d&gt; * f:(&#39;d -&gt; Parser&lt;&#39;e&gt;) -&gt; Parser&lt;&#39;e&gt;</div>
<div class="tip" id="ft54">val zeroOrMore : Parser&lt;&#39;a&gt; -&gt; Parser&lt;&#39;a list&gt;<br /><br />Full name: TryJoinads.ParseTranslation.zeroOrMore</div>
<div class="tip" id="ft55">member ParserBuilder.Return : v:&#39;g -&gt; Parser&lt;&#39;g&gt;</div>
<div class="tip" id="ft56">member ParserBuilder.Combine : p1:Parser&lt;&#39;b&gt; * p2:Parser&lt;&#39;b&gt; -&gt; Parser&lt;&#39;b&gt;</div>
<div class="tip" id="ft57">member ParserBuilder.ReturnFrom : m:&#39;f -&gt; &#39;f</div>
<div class="tip" id="ft58">val sat : (char -&gt; bool) -&gt; Parser&lt;char&gt;<br /><br />Full name: TryJoinads.sat<br /><em><br /><br />&#160;Primitive parser that parses a char if it matches a predicate</em></div>
<div class="tip" id="ft59">val f : (char -&gt; bool)</div>
<div class="tip" id="ft60">P (fun buffer -&gt; seq { <br />&#160;&#160;match buffer with <br />&#160;&#160;| x::xs when f x -&gt; yield x, xs <br />&#160;&#160;| _ -&gt; () })</div>
<div class="tip" id="ft61">val letter : Parser&lt;char&gt;<br /><br />Full name: TryJoinads.letter</div>
<div class="tip" id="ft62">namespace System</div>
<div class="tip" id="ft63">type Char =<br />&#160;&#160;struct<br />&#160;&#160;&#160;&#160;member CompareTo : obj -&gt; int<br />&#160;&#160;&#160;&#160;member CompareTo : char -&gt; int<br />&#160;&#160;&#160;&#160;member Equals : obj -&gt; bool<br />&#160;&#160;&#160;&#160;member Equals : char -&gt; bool<br />&#160;&#160;&#160;&#160;member GetHashCode : unit -&gt; int<br />&#160;&#160;&#160;&#160;member GetTypeCode : unit -&gt; System.TypeCode<br />&#160;&#160;&#160;&#160;member ToString : unit -&gt; string<br />&#160;&#160;&#160;&#160;member ToString : System.IFormatProvider -&gt; string<br />&#160;&#160;&#160;&#160;static val MaxValue : char<br />&#160;&#160;&#160;&#160;static val MinValue : char<br />&#160;&#160;&#160;&#160;static member GetNumericValue : char -&gt; float<br />&#160;&#160;&#160;&#160;static member GetNumericValue : string * int -&gt; float<br />&#160;&#160;&#160;&#160;static member GetUnicodeCategory : char -&gt; System.Globalization.UnicodeCategory<br />&#160;&#160;&#160;&#160;static member GetUnicodeCategory : string * int -&gt; System.Globalization.UnicodeCategory<br />&#160;&#160;&#160;&#160;static member IsControl : char -&gt; bool<br />&#160;&#160;&#160;&#160;static member IsControl : string * int -&gt; bool<br />&#160;&#160;&#160;&#160;static member IsDigit : char -&gt; bool<br />&#160;&#160;&#160;&#160;static member IsDigit : string * int -&gt; bool<br />&#160;&#160;&#160;&#160;static member IsLetter : char -&gt; bool<br />&#160;&#160;&#160;&#160;static member IsLetter : string * int -&gt; bool<br />&#160;&#160;&#160;&#160;static member IsLetterOrDigit : char -&gt; bool<br />&#160;&#160;&#160;&#160;static member IsLetterOrDigit : string * int -&gt; bool<br />&#160;&#160;&#160;&#160;static member IsLower : char -&gt; bool<br />&#160;&#160;&#160;&#160;static member IsLower : string * int -&gt; bool<br />&#160;&#160;&#160;&#160;static member IsNumber : char -&gt; bool<br />&#160;&#160;&#160;&#160;static member IsNumber : string * int -&gt; bool<br />&#160;&#160;&#160;&#160;static member IsPunctuation : char -&gt; bool<br />&#160;&#160;&#160;&#160;static member IsPunctuation : string * int -&gt; bool<br />&#160;&#160;&#160;&#160;static member IsSeparator : char -&gt; bool<br />&#160;&#160;&#160;&#160;static member IsSeparator : string * int -&gt; bool<br />&#160;&#160;&#160;&#160;static member IsSurrogate : char -&gt; bool<br />&#160;&#160;&#160;&#160;static member IsSurrogate : string * int -&gt; bool<br />&#160;&#160;&#160;&#160;static member IsSurrogatePair : string * int -&gt; bool<br />&#160;&#160;&#160;&#160;static member IsSurrogatePair : char * char -&gt; bool<br />&#160;&#160;&#160;&#160;static member IsSymbol : char -&gt; bool<br />&#160;&#160;&#160;&#160;static member IsSymbol : string * int -&gt; bool<br />&#160;&#160;&#160;&#160;static member IsUpper : char -&gt; bool<br />&#160;&#160;&#160;&#160;static member IsUpper : string * int -&gt; bool<br />&#160;&#160;&#160;&#160;static member IsWhiteSpace : char -&gt; bool<br />&#160;&#160;&#160;&#160;static member IsWhiteSpace : string * int -&gt; bool<br />&#160;&#160;&#160;&#160;static member ToLower : char -&gt; char<br />&#160;&#160;&#160;&#160;static member ToLower : char * System.Globalization.CultureInfo -&gt; char<br />&#160;&#160;&#160;&#160;static member ToLowerInvariant : char -&gt; char<br />&#160;&#160;&#160;&#160;static member ToString : char -&gt; string<br />&#160;&#160;&#160;&#160;static member ToUpper : char -&gt; char<br />&#160;&#160;&#160;&#160;static member ToUpper : char * System.Globalization.CultureInfo -&gt; char<br />&#160;&#160;&#160;&#160;static member ToUpperInvariant : char -&gt; char<br />&#160;&#160;&#160;&#160;static member TryParse : string * char -&gt; bool<br />&#160;&#160;end<br /><br />Full name: System.Char<br />&#160;&#160;type: System.Char<br />&#160;&#160;inherits: System.ValueType<br /></div>
<div class="tip" id="ft64">System.Char.IsLetter(c: char) : bool<br />System.Char.IsLetter(s: string, index: int) : bool</div>
<div class="tip" id="ft65">val number : Parser&lt;char&gt;<br /><br />Full name: TryJoinads.number</div>
<div class="tip" id="ft66">System.Char.IsNumber(c: char) : bool<br />System.Char.IsNumber(s: string, index: int) : bool</div>
<div class="tip" id="ft67">Multiple items<br />val unit : &#39;a -&gt; seq&lt;&#39;a&gt;<br /><br />Full name: TryJoinads.Sequence.unit<br /><em><br /><br />&#160;Returns a singleton sequence containing just &#39;v&#39;</em><br /><br />--------------------<br />type unit = Unit<br /><br />Full name: Microsoft.FSharp.Core.unit<br />&#160;&#160;type: unit<br /></div>
<div class="tip" id="ft68">val singleton : &#39;T -&gt; seq&lt;&#39;T&gt;<br /><br />Full name: Microsoft.FSharp.Collections.Seq.singleton</div>
<div class="tip" id="ft69">val bind : (&#39;a -&gt; #seq&lt;&#39;c&gt;) -&gt; seq&lt;&#39;a&gt; -&gt; seq&lt;&#39;c&gt;<br /><br />Full name: TryJoinads.Sequence.bind<br /><em><br /><br />&#160;Apply &#39;f&#39; to all elements and concatenate generated sequences</em></div>
<div class="tip" id="ft70">val f : (&#39;a -&gt; #seq&lt;&#39;c&gt;)</div>
<div class="tip" id="ft71">val s : seq&lt;&#39;a&gt;<br />&#160;&#160;type: seq&lt;&#39;a&gt;<br />&#160;&#160;inherits: System.Collections.IEnumerable<br /></div>
<div class="tip" id="ft72">val combine : &#39;a -&gt; &#39;a -&gt; seq&lt;&#39;b&gt; (requires &#39;a :&gt; seq&lt;&#39;b&gt;)<br /><br />Full name: TryJoinads.Sequence.combine<br /><em><br /><br />&#160;Concatenate elements of two sequences</em></div>
<div class="tip" id="ft73">val s1 : #seq&lt;&#39;b&gt;<br />&#160;&#160;type: #seq&lt;&#39;b&gt;<br /></div>
<div class="tip" id="ft74">val s2 : #seq&lt;&#39;b&gt;<br />&#160;&#160;type: #seq&lt;&#39;b&gt;<br /></div>
<div class="tip" id="ft75">val zero : unit -&gt; seq&lt;&#39;a&gt;<br /><br />Full name: TryJoinads.Sequence.zero<br /><em><br /><br />&#160;Returns an empty sequence</em></div>
<div class="tip" id="ft76">type SeqBuilder =<br />&#160;&#160;class<br />&#160;&#160;&#160;&#160;new : unit -&gt; SeqBuilder<br />&#160;&#160;&#160;&#160;member Combine : p1:&#39;b * p2:&#39;b -&gt; seq&lt;&#39;c&gt; (requires &#39;b :&gt; seq&lt;&#39;c&gt;)<br />&#160;&#160;&#160;&#160;member Delay : f:(unit -&gt; seq&lt;&#39;a&gt;) -&gt; seq&lt;&#39;a&gt;<br />&#160;&#160;&#160;&#160;member For : v:seq&lt;&#39;e&gt; * f:(&#39;e -&gt; #seq&lt;&#39;g&gt;) -&gt; seq&lt;&#39;g&gt;<br />&#160;&#160;&#160;&#160;member Yield : v:&#39;i -&gt; seq&lt;&#39;i&gt;<br />&#160;&#160;&#160;&#160;member YieldFrom : m:&#39;h -&gt; &#39;h<br />&#160;&#160;&#160;&#160;member Zero : unit -&gt; seq&lt;&#39;d&gt;<br />&#160;&#160;end<br /><br />Full name: TryJoinads.SeqBuilder<br /><em><br /><br />&#160;Computation builder for working with sequences</em></div>
<div class="tip" id="ft77">val x : SeqBuilder</div>
<div class="tip" id="ft78">member SeqBuilder.Yield : v:&#39;i -&gt; seq&lt;&#39;i&gt;<br /><br />Full name: TryJoinads.SeqBuilder.Yield</div>
<div class="tip" id="ft79">val v : &#39;i</div>
<div class="tip" id="ft80">module Sequence<br /><br />from TryJoinads</div>
<div class="tip" id="ft81">val unit : &#39;a -&gt; seq&lt;&#39;a&gt;<br /><br />Full name: TryJoinads.Sequence.unit<br /><em><br /><br />&#160;Returns a singleton sequence containing just &#39;v&#39;</em></div>
<div class="tip" id="ft82">member SeqBuilder.YieldFrom : m:&#39;h -&gt; &#39;h<br /><br />Full name: TryJoinads.SeqBuilder.YieldFrom</div>
<div class="tip" id="ft83">val m : &#39;h</div>
<div class="tip" id="ft84">member SeqBuilder.For : v:seq&lt;&#39;e&gt; * f:(&#39;e -&gt; #seq&lt;&#39;g&gt;) -&gt; seq&lt;&#39;g&gt;<br /><br />Full name: TryJoinads.SeqBuilder.For</div>
<div class="tip" id="ft85">val v : seq&lt;&#39;e&gt;<br />&#160;&#160;type: seq&lt;&#39;e&gt;<br />&#160;&#160;inherits: System.Collections.IEnumerable<br /></div>
<div class="tip" id="ft86">val f : (&#39;e -&gt; #seq&lt;&#39;g&gt;)</div>
<div class="tip" id="ft87">member SeqBuilder.Zero : unit -&gt; seq&lt;&#39;d&gt;<br /><br />Full name: TryJoinads.SeqBuilder.Zero</div>
<div class="tip" id="ft88">member SeqBuilder.Combine : p1:&#39;b * p2:&#39;b -&gt; seq&lt;&#39;c&gt; (requires &#39;b :&gt; seq&lt;&#39;c&gt;)<br /><br />Full name: TryJoinads.SeqBuilder.Combine</div>
<div class="tip" id="ft89">val p1 : #seq&lt;&#39;c&gt;<br />&#160;&#160;type: #seq&lt;&#39;c&gt;<br /></div>
<div class="tip" id="ft90">val p2 : #seq&lt;&#39;c&gt;<br />&#160;&#160;type: #seq&lt;&#39;c&gt;<br /></div>
<div class="tip" id="ft91">member SeqBuilder.Delay : f:(unit -&gt; seq&lt;&#39;a&gt;) -&gt; seq&lt;&#39;a&gt;<br /><br />Full name: TryJoinads.SeqBuilder.Delay</div>
<div class="tip" id="ft92">val f : (unit -&gt; seq&lt;&#39;a&gt;)</div>
<div class="tip" id="ft93">val delay : (unit -&gt; seq&lt;&#39;T&gt;) -&gt; seq&lt;&#39;T&gt;<br /><br />Full name: Microsoft.FSharp.Collections.Seq.delay</div>
<div class="tip" id="ft94">val sq : SeqBuilder<br /><br />Full name: TryJoinads.sq<br /><em><br /><br />&#160;A unique instance of the computation builder</em></div>
<div class="tip" id="ft95">val fibs : seq&lt;int&gt;<br /><br />Full name: TryJoinads.fibs<br />&#160;&#160;type: seq&lt;int&gt;<br />&#160;&#160;inherits: System.Collections.IEnumerable<br /></div>
<div class="tip" id="ft96">val a : int<br />&#160;&#160;type: int<br />&#160;&#160;inherits: System.ValueType<br /></div>
<div class="tip" id="ft97">val b : int<br />&#160;&#160;type: int<br />&#160;&#160;inherits: System.ValueType<br /></div>
<div class="tip" id="ft98">val zip : seq&lt;&#39;T1&gt; -&gt; seq&lt;&#39;T2&gt; -&gt; seq&lt;&#39;T1 * &#39;T2&gt;<br /><br />Full name: Microsoft.FSharp.Collections.Seq.zip</div>
<div class="tip" id="ft99">val skip : int -&gt; seq&lt;&#39;T&gt; -&gt; seq&lt;&#39;T&gt;<br /><br />Full name: Microsoft.FSharp.Collections.Seq.skip</div>
<div class="tip" id="ft100">val take : int -&gt; seq&lt;&#39;T&gt; -&gt; seq&lt;&#39;T&gt;<br /><br />Full name: Microsoft.FSharp.Collections.Seq.take</div>
<div class="tip" id="ft101">val fibs : seq&lt;int&gt;<br /><br />Full name: TryJoinads.SeqTranslation.fibs<br />&#160;&#160;type: seq&lt;int&gt;<br />&#160;&#160;inherits: System.Collections.IEnumerable<br /></div>
<div class="tip" id="ft102">member SeqBuilder.Delay : f:(unit -&gt; seq&lt;&#39;a&gt;) -&gt; seq&lt;&#39;a&gt;</div>
<div class="tip" id="ft103">member SeqBuilder.Combine : p1:&#39;b * p2:&#39;b -&gt; seq&lt;&#39;c&gt; (requires &#39;b :&gt; seq&lt;&#39;c&gt;)</div>
<div class="tip" id="ft104">member SeqBuilder.YieldFrom : m:&#39;h -&gt; &#39;h</div>
<div class="tip" id="ft105">member SeqBuilder.For : v:seq&lt;&#39;e&gt; * f:(&#39;e -&gt; #seq&lt;&#39;g&gt;) -&gt; seq&lt;&#39;g&gt;</div>
<div class="tip" id="ft106">member SeqBuilder.Yield : v:&#39;i -&gt; seq&lt;&#39;i&gt;</div>
<div class="tip" id="ft107">val m : ParserBuilder<br /><br />Full name: TryJoinads.m</div>
<div class="tip" id="ft108">val shouldEqual : Parser&lt;&#39;a&gt; -&gt; Parser&lt;&#39;b&gt; -&gt; &#39;c<br /><br />Full name: TryJoinads.shouldEqual</div>
<div class="tip" id="ft109">val a : (char list -&gt; seq&lt;&#39;a * char list&gt;)</div>
<div class="tip" id="ft110">val b : (char list -&gt; seq&lt;&#39;b * char list&gt;)</div>
<div class="tip" id="ft111">val failwith : string -&gt; &#39;T<br /><br />Full name: Microsoft.FSharp.Core.Operators.failwith</div>
<div class="tip" id="ft112">val monoidAssociativity : Parser&lt;&#39;a&gt; -&gt; Parser&lt;&#39;a&gt; -&gt; Parser&lt;&#39;a&gt; -&gt; &#39;b<br /><br />Full name: TryJoinads.monoidAssociativity<br /><em><br /><br />&#160;The associativity monoid law </em></div>
<div class="tip" id="ft113">val n1 : Parser&lt;&#39;a&gt;</div>
<div class="tip" id="ft114">val n2 : Parser&lt;&#39;a&gt;</div>
<div class="tip" id="ft115">val n3 : Parser&lt;&#39;a&gt;</div>
<div class="tip" id="ft116">val m1 : Parser&lt;&#39;a&gt;</div>
<div class="tip" id="ft117">val m2 : Parser&lt;&#39;a&gt;</div>
<div class="tip" id="ft118">Multiple items<br />val unit : Parser&lt;&#39;a&gt; -&gt; Parser&lt;&#39;a&gt; -&gt; &#39;b<br /><br />Full name: TryJoinads.unit<br /><em><br /><br />&#160;The unit monoid laws </em><br /><br />--------------------<br />type unit = Unit<br /><br />Full name: Microsoft.FSharp.Core.unit<br />&#160;&#160;type: unit<br /></div>
<div class="tip" id="ft119">val m3 : Parser&lt;&#39;a&gt;</div>
<div class="tip" id="ft120">val leftIdentity : &#39;a -&gt; (&#39;a -&gt; Parser&lt;&#39;b&gt;) -&gt; &#39;c<br /><br />Full name: TryJoinads.leftIdentity<br /><em><br /><br />&#160;The left identity monad law</em></div>
<div class="tip" id="ft121">val m1 : Parser&lt;&#39;b&gt;</div>
<div class="tip" id="ft122">val m2 : Parser&lt;&#39;b&gt;</div>
<div class="tip" id="ft123">val rightIdentity : Parser&lt;&#39;a&gt; -&gt; &#39;b<br /><br />Full name: TryJoinads.rightIdentity<br /><em><br /><br />&#160;The right identity monad law </em></div>
<div class="tip" id="ft124">val n : Parser&lt;&#39;a&gt;</div>
<div class="tip" id="ft125">val monadAssociativity : Parser&lt;&#39;a&gt; -&gt; (&#39;a -&gt; Parser&lt;&#39;a&gt;) -&gt; (&#39;a -&gt; Parser&lt;&#39;b&gt;) -&gt; &#39;c<br /><br />Full name: TryJoinads.monadAssociativity<br /><em><br /><br />&#160;The associativity monad law </em></div>
<div class="tip" id="ft126">val f : (&#39;a -&gt; Parser&lt;&#39;a&gt;)</div>
<div class="tip" id="ft127">val g : (&#39;a -&gt; Parser&lt;&#39;b&gt;)</div>
<div class="tip" id="ft128">val y : &#39;a</div>
<div class="tip" id="ft129">val m3 : Parser&lt;&#39;b&gt;</div>
<div class="tip" id="ft130">val leftZero : Parser&lt;&#39;a&gt; -&gt; (&#39;a -&gt; Parser&lt;&#39;b&gt;) -&gt; &#39;c<br /><br />Full name: TryJoinads.leftZero<br /><em><br /><br />&#160;Left zero law of additive monads</em></div>
<div class="tip" id="ft131">val k : (&#39;a -&gt; Parser&lt;&#39;b&gt;)</div>

  </body>
  </html>